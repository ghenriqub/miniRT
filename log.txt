
===== srcs/parser/0-main.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   0-main.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:44:29 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/01 16:42:17 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

/*
static void ft_print_vec3(t_vec3 v)
{
    printf("(%.3f, %.3f, %.3f)", v.x, v.y, v.z);
}

static void ft_print_rgb(t_rgb c)
{
    printf("(%d, %d, %d)", c.r, c.g, c.b);
}

static const char *ft_obj_name(t_obj_type t)
{
    if (t == SPHERE) return "SPHERE";
    if (t == PLANE) return "PLANE";
    if (t == CYLINDER) return "CYLINDER";
    return "UNKNOWN";
}

static void ft_print_object_data(t_object *obj)
{
    if (!obj || !obj->data)
        return;

    if (obj->type == SPHERE)
    {
        t_sphere *s = (t_sphere *)obj->data;
        printf("      center = ");
        ft_print_vec3(s->center);
        printf("\n      diameter = %.3f\n", s->diameter);
    }
    else if (obj->type == PLANE)
    {
        t_plane *p = (t_plane *)obj->data;
        printf("      point  = ");
        ft_print_vec3(p->point);
        printf("\n      normal = ");
        ft_print_vec3(p->normal);
        printf("\n");
    }
    else if (obj->type == CYLINDER)
    {
        t_cylinder *c = (t_cylinder *)obj->data;
        printf("      center = ");
        ft_print_vec3(c->center);
        printf("\n      normal = ");
        ft_print_vec3(c->normal);
        printf("\n      diameter = %.3f\n", c->diameter);
        printf("      height = %.3f\n", c->height);
    }
}

void ft_print_scene(t_scene *scene)
{
    if (!scene)
        return;

    printf("\n=========== SCENE ===========\n");

    // AMBIENT LIGHT 
    if (scene->ambient)
    {
        printf("\nAmbient Light:\n");
        printf("  ratio = %.3f\n", scene->ambient->ratio);
        printf("  color = ");
        ft_print_rgb(scene->ambient->color);
        printf("\n");
    }

    // CAMERA 
    if (scene->camera)
    {
        printf("\nCamera:\n");
        printf("  position = ");
        ft_print_vec3(scene->camera->position);
        printf("\n  vector   = ");
        ft_print_vec3(scene->camera->vector);
        printf("\n  fov      = %d\n", scene->camera->fov);
    }

    // LIGHTS 
    printf("\nLights (%d):\n", scene->light_count);
    for (int i = 0; i < scene->light_count; i++)
    {
        printf("  Light %d:\n", i);
        printf("    position = ");
        ft_print_vec3(scene->lights[i]->position);
        printf("\n    ratio = %.3f\n", scene->lights[i]->ratio);
        printf("    color = ");
        ft_print_rgb(scene->lights[i]->color);
        printf("\n");
    }

    // OBJECTS 
    printf("\nObjects (%d):\n", scene->object_count);
    for (int i = 0; i < scene->object_count; i++)
    {
        printf("  Object %d:\n", i);
        printf("    type = %s\n", ft_obj_name(scene->objects[i]->type));
        ft_print_object_data(scene->objects[i]);
    }

    printf("\n==============================\n\n");
}
*/

int	main(int argc, char **argv)
{
	t_scene	*scene;

	if (argc != 2 || ft_is_rt(argv[1]))
		ft_exit(ERROR_PARAM, 1);
	scene = ft_get_scene(argv[1]);
	// ft_print_scene(scene);
	ft_free_scene(scene);
	return (0);
}

void	ft_exit(char *message, int code)
{
	if (message)
		ft_putendl_fd(message, 2);
	exit(code);
}

===== srcs/parser/1-get_scene.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   1-get_args.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 16:20:41 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/18 15:39:00 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// 1 - fill Args struct with user input
// 2 - Arguments Parser, if all is ok, return struct scene
t_scene	*ft_get_scene(char *file)
{
	t_args	*args;
	t_scene	*scene;

	args = ft_allocate_args(file);
	scene = ft_parser(args);
	ft_free_args(args);
	return (scene);
}

===== srcs/parser/2-allocate.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   2-allocate.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/15 12:08:27 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 20:49:06 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

static int	ft_is_object(char *line)
{
	int	i;

	i = 0;
	if (!line)
		return (0);
	while (line[i] == ' ')
		i++;
	if (!ft_strncmp(&line[i], "sp ", 3))
		return (1);
	if (!ft_strncmp(&line[i], "pl ", 3))
		return (1);
	if (!ft_strncmp(&line[i], "cy ", 3))
		return (1);
	return (0);
}

static int	*ft_count(char *file)
{
	int		*count;
	int		fd;
	char	*line;
	int		i;

	count = ft_calloc(2, sizeof(int));
	if (!count)
		ft_exit(ERROR_MALLOC, 2);
	fd = ft_get_fd(file);
	line = ft_strtrim(get_next_line(fd), " \t\r\b\n");
	while (line)
	{
		i = 0;
		ft_tab_to_space(line);
		while (line[i] == ' ')
			i++;
		if (!ft_strncmp(&line[i], "L ", 2))
			count[0]++;
		else if (ft_is_object(line))
			count[1]++;
		free(line);
		line = ft_strtrim(get_next_line(fd), " \t\r\b\n");
	}
	close(fd);
	return (count);
}

static char	*ft_is_double(t_args *args, char *target, char *line, int fd)
{
	if (target)
	{
		free(line);
		ft_free_args(args);
		close(fd);
		ft_exit(ERROR_SCENE, 2);
	}
	return (ft_strdup(line));
}

// 1 - set args NULL
// 2 - strtrim for erase spaces
// 3 - fill scruct according the type of the lines
// 4 - Cam and ambient light can't duplicate
// if invalid argument, call ft_is_double for free and exit
void	ft_put_argument(t_args *args, int fd)
{
	int		i;
	int		k;
	char	*line;

	args->ambient_light = NULL;
	i = 0;
	k = 0;
	line = ft_strtrim(get_next_line(fd), " \t\r\b\n");
	while (line)
	{
		ft_tab_to_space(line);
		if (!ft_strncmp(line, "A ", 2))
			args->ambient_light = ft_is_double(args,
					args->ambient_light, line, fd);
		else if (!ft_strncmp(line, "C ", 2))
			args->camera = ft_is_double(args, args->camera, line, fd);
		else if (!ft_strncmp(line, "L ", 2))
			args->light[k++] = ft_strdup(line);
		else if (ft_is_object(line))
			args->objects[i++] = ft_strdup(line);
		else if (line[0] != '\n' && line[0] != '#')
			ft_is_double(args, "invalid", line, fd);
		free(line);
		line = ft_strtrim(get_next_line(fd), " \t\r\b\n");
	}
}

// 1- call ft_count to get number of the Lights and objets
// 2 - allocate memory for struct and arrays-arrays
// 3 - call ft_put_argument to fill struct
t_args	*ft_allocate_args(char *file)
{
	t_args	*args;
	int		*count;
	int		fd;

	count = ft_count(file);
	args = ft_calloc(sizeof(t_args), 1);
	args->camera = NULL;
	args->light_count = count[0];
	args->obj_count = count[1];
	free(count);
	args->objects = ft_calloc(sizeof(char *), (args->obj_count + 1));
	if (!args->objects)
		ft_exit(ERROR_MALLOC, 2);
	args->objects[args->obj_count] = NULL;
	if (args->light_count > 0)
	{
		args->light = ft_calloc(sizeof(char *), (args->light_count + 1));
		if (!args->light_count)
			ft_exit(ERROR_MALLOC, 2);
		args->objects[args->light_count] = NULL;
	}
	fd = ft_get_fd(file);
	ft_put_argument(args, fd);
	close(fd);
	return (args);
}

===== srcs/parser/3-parser.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3-parser.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/15 12:38:39 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 21:41:36 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_scene	*ft_parser(t_args *args)
{
	t_scene	*scene;

	scene = ft_calloc(sizeof(t_scene), 1);
	scene->light_count = args->light_count;
	scene->object_count = args->obj_count;
	scene->ambient = ft_parser_al(args->ambient_light);
	scene->camera = ft_parser_c(args->camera);
	scene->lights = ft_parser_l(args->light, scene->light_count);
	scene->objects = ft_parser_ob(args->objects, scene->object_count);
	if (scene->ambient == NULL || scene->camera == NULL
		|| (scene->light_count > 0 && scene->lights == NULL)
		|| (scene->objects == NULL))
	{
		ft_free_args(args);
		ft_free_scene(scene);
		ft_exit(ERROR_SCENE, 2);
	}
	return (scene);
}

// 1 - count parts to verified if have 3 arguments.
// 2 - if with 3 condictions:
//		first argument is 'A'.
//			parser ratio, if arguments is a float 0.0 - 1.0.
//				parser RGB xxx,xxx,xxx.
// 3 - strdup and get rgb for allocate arguments.
t_ambient_light	*ft_parser_al(char *input)
{
	t_ambient_light	*al;
	char			**args;

	if (count_parts(input, ' ') != 3)
		return (NULL);
	args = ft_split(input, ' ');
	if (ft_strncmp(args[0], "A", ft_strlen(args[0])) != 0
		|| !ft_parser_ratio(args[1], 0.0, 1.0)
		|| !ft_parser_rgb(args[2]))
	{
		ft_free_split(args);
		return (NULL);
	}
	al = ft_calloc(sizeof(t_ambient_light), 1);
	al->ratio = ft_atof(args[1]);
	al->color = ft_get_rgb(args[2]);
	ft_free_split(args);
	return (al);
}

t_camera	*ft_parser_c(char *input)
{
	t_camera	*camera;
	char		**args;

	if (count_parts(input, ' ') != 4)
		return (NULL);
	args = ft_split(input, ' ');
	if (ft_strncmp(args[0], "C", ft_strlen(args[0])) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_parse_fov(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	camera = ft_calloc(sizeof(t_camera), 1);
	camera->position = ft_get_vec3(args[1]);
	camera->vector = ft_get_vec3(args[2]);
	camera->fov = atof(args[3]);
	ft_free_split(args);
	return (camera);
}

t_light	**ft_parser_l(char **input, int count_light)
{
	t_light	**light;
	char	**args;
	int		i;

	light = (t_light **)ft_alloc_arraystruc(count_light, sizeof(t_light));
	if (!light)
		return (NULL);
	i = -1;
	while (input[++i])
	{
		if (count_parts(input[i], ' ') != 4)
			return (ft_free_arraystruc((void **)light, count_light), NULL);
		args = ft_split(input[i], ' ');
		if (ft_strncmp(args[0], "L", ft_strlen(args[0])) != 0
			|| !ft_parser_vec3(args[1])
			|| !ft_parser_ratio(args[2], 0, 1)
			|| !ft_parser_rgb(args[3]))
			return (ft_free_arraystruc((void **)light, count_light),
				ft_free_split(args), NULL);
		light[i]->position = ft_get_vec3(args[1]);
		light[i]->ratio = ft_atof(args[2]);
		light[i]->color = ft_get_rgb(args[3]);
		ft_free_split(args);
	}
	return (light);
}

t_object	**ft_parser_ob(char **input, int count_objects)
{
	t_object	**objects;
	int			i;

	objects = (t_object **)ft_alloc_arraystruc(count_objects, sizeof(t_object));
	if (!objects)
		return (NULL);
	i = -1;
	while (++i < count_objects)
	{
		objects[i]->type = ft_get_type(input[i]);
		if (objects[i]->type == INVALID)
			return (ft_free_objects_struc(objects, count_objects), NULL);
		objects[i]->data = ft_get_obj(objects[i]->type, input[i]);
		if (objects[i]->data == NULL)
			return (ft_free_objects_struc(objects, count_objects), NULL);
	}
	return (objects);
}

===== srcs/parser/3.1-parser_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.1-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/19 16:20:22 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 21:59:27 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// verified if all str value is a number
int	ft_is_number(char *str)
{
	int	i;

	i = 0;
	if (!str || !*str)
		return (0);
	while (str[i])
	{
		if (str[i] < '0' || str[i] > '9')
			return (0);
		i++;
	}
	return (1);
}

// 1 - verified if have 3 parts when we split with ","
// 2 - check if each part is a number and if it are between 0 - 255. 
int	ft_parser_rgb(char *str)
{
	char	**s;
	int		i;
	int		value;

	s = ft_split(str, ',');
	if (!s || count_parts(str, ',') != 3)
		return (ft_free_split(s), 0);
	i = -1;
	while (++i < 3)
	{
		if (!ft_is_number(s[i]))
			return (ft_free_split(s), 0);
		value = ft_atoi(s[i]);
		if (value < 0 || value > 255)
			return (ft_free_split(s), 0);
	}
	ft_free_split(s);
	return (1);
}

// 1- call float format for check if the argument is a float
// 2 - check if value are between min and max
int	ft_parser_ratio(char *str, float min, float max)
{
	float	value;

	if (!ft_float_format(str))
		return (0);
	value = ft_atof(str);
	if (value < min || value > max)
		return (0);
	return (1);
}

// 1 - verify if have 3 parts when we split with ",".
// 2 - check if all parts are in float format.
int	ft_parser_vec3(char *str)
{
	char	**p;

	p = ft_split(str, ',');
	if (!p || count_parts(str, ',') != 3)
		return (ft_free_split(p), 0);
	if (!ft_float_format(p[0])
		|| !ft_float_format(p[1])
		|| !ft_float_format(p[2]))
		return (ft_free_split(p), 0);
	ft_free_split(p);
	return (1);
}

// 1 - call parser vec3 for verify if str is a vector with 3 argument
// 2 - call parser ratio, check if is a float and between -1 and 1.
int	ft_is_normalized(char *str)
{
	char	**args;

	if (!ft_parser_vec3(str))
		return (0);
	args = ft_split(str, ',');
	if (!ft_parser_ratio(args[0], -1, 1)
		|| !ft_parser_ratio(args[1], -1, 1)
		|| !ft_parser_ratio(args[2], -1, 1))
	{
		ft_free_split(args);
		return (0);
	}
	ft_free_split(args);
	return (1);
}

===== srcs/parser/3.2-parser_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.2-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 14:13:09 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 22:03:20 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// verify if is a float and if are between 0 - 180.
int	ft_parse_fov(char *str)
{
	float	fov;

	if (!ft_float_format(str))
		return (0);
	fov = ft_atof(str);
	if (fov < 0 || fov > 180)
		return (0);
	return (1);
}

// verify if is a digit and if have 0 or 1 point
static int	ft_float_format_util(const char *str)
{
	int	i;
	int	digits;
	int	dots;

	i = 0;
	digits = 0;
	dots = 0;
	while (str[i])
	{
		if (str[i] >= '0' && str[i] <= '9')
			digits++;
		else if (str[i] == '.')
		{
			if (++dots > 1 || !str[i + 1])
				return (0);
		}
		else
			return (0);
		i++;
	}
	return (digits > 0);
}

// verify if have a signal, and call util
int	ft_float_format(const char *str)
{
	int	i;

	if (!str || !*str)
		return (0);
	i = 0;
	if (str[i] == '+' || str[i] == '-')
		i++;
	if (!str[i])
		return (0);
	return (ft_float_format_util(&str[i]));
}

// used for free scructs
void	**ft_alloc_arraystruc(int count, size_t type_size)
{
	void	**arr;
	int		i;

	if (count <= 0)
		return (NULL);
	arr = ft_calloc(count + 1, sizeof(void *));
	if (!arr)
		return (NULL);
	i = 0;
	while (i < count)
	{
		arr[i] = ft_calloc(1, type_size);
		if (!arr[i])
		{
			while (--i >= 0)
				free(arr[i]);
			free(arr);
			return (NULL);
		}
		i++;
	}
	arr[count] = NULL;
	return (arr);
}

===== srcs/parser/3.3-parser_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.3-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/19 17:02:49 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 22:05:29 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// split str and return struct RGB.
t_rgb	ft_get_rgb(char *str)
{
	t_rgb	rgb;
	char	**vals;

	vals = ft_split(str, ',');
	rgb.r = ft_atoi(vals[0]);
	rgb.g = ft_atoi(vals[1]);
	rgb.b = ft_atoi(vals[2]);
	ft_free_split(vals);
	return (rgb);
}

// ft_float second part, decimal part. 
static void	ft_atof_decimal_part(const char *str, int *i, float *result)
{
	float	decimal;

	decimal = 0.1f;
	if (str[*i] != '.')
		return ;
	(*i)++;
	while (str[*i] >= '0' && str[*i] <= '9')
	{
		*result += (str[*i] - '0') * decimal;
		decimal *= 0.1f;
		(*i)++;
	}
}

// ascii to float, first part is the left number
float	ft_atof(const char *str)
{
	int		i;
	int		sign;
	float	result;

	i = 0;
	sign = 1;
	result = 0.0f;
	while (str[i] == ' ' || str[i] == '\t')
		i++;
	if (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}
	while (str[i] >= '0' && str[i] <= '9')
	{
		result = result * 10.0f + (str[i] - '0');
		i++;
	}
	ft_atof_decimal_part(str, &i, &result);
	return (result * sign);
}

// return a vector with 3 values.
t_vec3	ft_get_vec3(char *str)
{
	t_vec3	v;
	char	**parts;

	parts = ft_split(str, ',');
	v.x = ft_atof(parts[0]);
	v.y = ft_atof(parts[1]);
	v.z = ft_atof(parts[2]);
	ft_free_split(parts);
	return (v);
}

// translate \t to ' '
char	*ft_tab_to_space(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (str[i] == '\t')
			str[i] = ' ';
		i++;
	}
	return (str);
}

===== srcs/parser/3.4-parser_obj_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.4-parser_obj_utils.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 16:55:35 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 22:06:35 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

void	*ft_parser_sphere(char *line)
{
	t_sphere	*sp;
	char		**args;

	if (count_parts(line, ' ') != 4)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "sp", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_float_format(args[2])
		|| !ft_parser_rgb(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	sp = ft_calloc(1, sizeof(t_sphere));
	sp->center = ft_get_vec3(args[1]);
	sp->diameter = ft_atof(args[2]);
	sp->color = ft_get_rgb(args[3]);
	ft_free_split(args);
	return (sp);
}

void	*ft_parser_plane(char *line)
{
	t_plane	*pl;
	char	**args;

	if (count_parts(line, ' ') != 4)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "pl", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_parser_rgb(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	pl = ft_calloc(1, sizeof(t_plane));
	pl->point = ft_get_vec3(args[1]);
	pl->normal = ft_get_vec3(args[2]);
	pl->color = ft_get_rgb(args[3]);
	ft_free_split(args);
	return (pl);
}

void	*ft_parser_cylinder(char *line)
{
	t_cylinder	*cy;
	char		**args;

	if (count_parts(line, ' ') != 6)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "cy", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_float_format(args[3])
		|| !ft_float_format(args[4])
		|| !ft_parser_rgb(args[5]))
		return (ft_free_split(args), NULL);
	cy = ft_calloc(1, sizeof(t_cylinder));
	cy->center = ft_get_vec3(args[1]);
	cy->normal = ft_get_vec3(args[2]);
	cy->diameter = ft_atof(args[3]);
	cy->height = ft_atof(args[4]);
	cy->color = ft_get_rgb(args[5]);
	ft_free_split(args);
	return (cy);
}

// return struct according to type.
void	*ft_get_obj(t_obj_type type, char *line)
{
	if (type == SPHERE)
		return (ft_parser_sphere(line));
	if (type == PLANE)
		return (ft_parser_plane(line));
	if (type == CYLINDER)
		return (ft_parser_cylinder(line));
	return (NULL);
}

// define the type of the object
t_obj_type	ft_get_type(char *line)
{
	if (!ft_strncmp(line, "sp ", 3))
		return (SPHERE);
	if (!ft_strncmp(line, "pl ", 3))
		return (PLANE);
	if (!ft_strncmp(line, "cy ", 3))
		return (CYLINDER);
	return (INVALID);
}

===== srcs/parser/support_functions.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_functions.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:46:12 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 22:06:47 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// this function verified if argument is .rt
int	ft_is_rt(char *file)
{
	size_t	len;

	len = ft_strlen(file);
	if (ft_strncmp(&file[len - 3], ".rt", 3))
		return (1);
	return (0);
}

int	ft_get_fd(char *file)
{
	int	fd;

	fd = open(file, O_RDONLY);
	if (fd < 0)
		ft_exit(ERROR_FILE, 2);
	return (fd);
}

void	ft_free_split(char **arr)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

void	ft_free_args(t_args *args)
{
	if (args->ambient_light)
		free(args->ambient_light);
	if (args->camera)
		free(args->camera);
	if (args->light)
		ft_free_split(args->light);
	if (args->objects)
		ft_free_split(args->objects);
	free(args);
}

===== srcs/parser/support_functions1.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_functions1.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 16:13:14 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 22:07:26 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"
/*this file have free functions.*/

void	ft_free_arraystruc(void **arr, int count)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (i < count)
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

void	ft_free_scene(t_scene *scene)
{
	int	i;

	if (!scene)
		return ;
	free(scene->ambient);
	free(scene->camera);
	if (scene->lights)
	{
		i = -1;
		while (scene->lights[++i])
			free(scene->lights[i]);
		free(scene->lights);
	}
	if (scene->objects)
		ft_free_objects_struc(scene->objects, scene->object_count);
	free(scene);
}

void	ft_free_objectt(t_object *obj)
{
	if (!obj)
		return ;
	if (obj->data)
	{
		if (obj->type == SPHERE)
			free((t_sphere *)obj->data);
		else if (obj->type == PLANE)
			free((t_plane *)obj->data);
		else if (obj->type == CYLINDER)
			free((t_cylinder *)obj->data);
	}
	free(obj);
}

void	ft_free_objects_struc(t_object **arr, int count)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (i < count)
	{
		ft_free_objectt(arr[i]);
		i++;
	}
	free(arr);
}

===== srcs/vectors/vec3_new.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_new.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:44:22 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 18:46:21 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3  vec3_new(double x, double y, double z)
{
    return ((t_vec3){x, y, z});
}

===== srcs/vectors/vec3_add.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_add.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:46:45 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 19:11:07 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3  vec3_add(t_vec3 vec1, t_vec3 vec2)
{
    return (vec3_new(vec1.x + vec2.x, vec1.y + vec2.y, vec1.z + vec2.z));
}

===== srcs/vectors/vec3_cross.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_cross.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:59:59 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 19:03:42 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_cross(t_vec3 vec1, t_vec3 vec2)
{
	t_vec3	res;

	res.x = vec1.y * vec2.z - vec1.z * vec2.y;
	res.y = vec1.z * vec2.x - vec1.z * vec2.z;
	res.z = vec1.x * vec2.y - vec1.z * vec2.x;
	return (res);
}

===== srcs/vectors/vec3_dot.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_dot.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:04:13 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 19:06:01 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

double  vec3_dot(t_vec3 vec1, t_vec3 vec2)
{
    return (vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z);
}

===== srcs/vectors/vec3_cos.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_cos.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:58:24 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 19:17:26 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

double  vec3_cos(t_vec3 vec1, t_vec3 vec2)
{
    double  dot;
    double  len;

    dot = vec3_dot(vec1, vec2);
    len = vec3_len(vec1) * vec3_len(vec2);
    return (dot / len);
}

===== srcs/vectors/vec3_cmp.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_compare.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:54:32 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 19:16:38 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

bool  vec3_cmp(t_vec3 vec1, t_vec3 vec2)
{
    return (vec1.x == vec2.x && vec1.y == vec2.y && vec1.z == vec2.z);
}

===== srcs/vectors/vec3_len.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_length.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:12:11 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 19:17:13 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

double  vec3_len(t_vec3 vec)
{
    return (sqrt(pow(vec.x, 2) + pow(vec.y, 2) + pow(vec.z, 2)));
}

===== srcs/vectors/vec3_atovec3.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_atovec3.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:18:28 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/30 17:57:16 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3  atovec3(char **vec)
{
    return ((t_vec3)
        {
            .x = ft_atod(vec[X]),
            .y = ft_atod(vec[Y]),
            .z = ft_atod(vec[Z]),
        }
    );
}

===== srcs/vectors/vec3_normalize.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_normalize.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:28:05 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 19:43:38 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3  vec3_normalize(t_vec3 vec)
{
    return (vec3_scale(vec, 1.0 / vec3_len(vec)));
}

===== srcs/vectors/vec3_scale.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_scale.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:29:21 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 19:31:25 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3  vec3_scale(t_vec3 vec1, double scalar)
{
    return (vec3_new(vec1.x * scalar, vec1.y * scalar, vec1.z * scalar));
}

===== srcs/vectors/vec3_sub.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_sub.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:35:48 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/11/23 19:37:53 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3  vec3_sub(t_vec3 vec1, t_vec3 vec2)
{
    return (vec3_new(vec1.x - vec2.x, vec1.y - vec2.y, vec1.z - vec2.z));
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minirt.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:42:30 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/01 16:38:54 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINIRT_H
# define MINIRT_H

# include "libft.h"
# include <stdbool.h>
# include <math.h>

# define ERROR_PARAM "Error\nUsage: ./minirt <file.rt>"
# define ERROR_FILE "Error\nCannot open this found."
# define ERROR_MALLOC "Error\nCannot allocate memmory."
# define ERROR_SCENE "Error\ninvalid scene."

typedef struct s_args
{
	char	*ambient_light;
	char	*camera;
	char	**light;
	int		light_count;
	char	**objects;
	int		obj_count;
}	t_args;

typedef struct s_vec3
{
	float	x;
	float	y;
	float	z;
}	t_vec3;

typedef struct s_rgb
{
	int	r;
	int	g;
	int	b;
}	t_rgb;

typedef struct s_ambient_light
{
	float	ratio;
	t_rgb	color;
}	t_ambient_light;

typedef struct s_camera
{
	t_vec3	position;
	t_vec3	vector;
	int		fov;
}	t_camera;

typedef struct s_light
{
	t_vec3	position;
	float	ratio;
	t_rgb	color;
}	t_light;

typedef struct s_sphere
{
	t_vec3	center;
	float	diameter;
	t_rgb	color;
}	t_sphere;

typedef struct s_plane
{
	t_vec3	point;
	t_vec3	normal;
	t_rgb	color;
}	t_plane;

typedef struct s_cylinder
{
	t_vec3	center;
	t_vec3	normal;
	float	diameter;
	float	height;
	t_rgb	color;
}	t_cylinder;

typedef enum e_obj_type
{
	SPHERE,
	PLANE,
	CYLINDER,
	INVALID
}	t_obj_type;

typedef struct s_object
{
	t_obj_type	type;
	void		*data;
}	t_object;

typedef struct s_scene
{
	t_ambient_light	*ambient;
	t_camera		*camera;
	t_light			**lights;
	int				light_count;
	t_object		**objects;
	int				object_count;
}	t_scene;

// typedef struct s_graphics
// {
// 	void	*mlx;
// 	void	*win;
// 	void	*img;
// 	char	*addr;
// 	int		height;
// 	int		width;
// 	int		bpp;
// 	int		line_length;
// 	int		endian;
// }	t_graphics;

// typedef struct s_world
// {
// 	t_camera	camera;
// 	t_light		ambient;
// 	t_vec3		*lights;
// 	t_vec3		*shapes;
// 	int			counters[3];
// 	t_graphics	disp;
// 	t_vec3		up;
// 	t_vec3		right;
// 	char		**map;
// 	double		hview;
// 	double		wview;
// }	t_world;

// ============ Parser ============

void			ft_exit(char *message, int code);
int				ft_is_rt(char *file);
t_scene			*ft_get_scene(char *file);
int				ft_get_fd(char *file);
void			ft_put_argument(t_args *args, int fd);
void			ft_free_args(t_args *args);
t_scene			*ft_parser(t_args *args);
t_args			*ft_allocate_args(char *file);
t_ambient_light	*ft_parser_al(char *input);
t_camera		*ft_parser_c(char *input);
t_light			**ft_parser_l(char **input, int count_light);
t_object		**ft_parser_ob(char **input, int count_objects);
t_rgb			ft_get_rgb(char *str);
float			ft_atof(const char *str);
int				ft_parser_rgb(char *str);
t_camera		*ft_parser_c(char *input);
int				ft_parser_ratio(char *str, float min, float max);
int				ft_is_normalized(char *str);
int				ft_is_number(char *str);
int				ft_parser_vec3(char *str);
t_vec3			ft_get_vec3(char *str);
int				ft_float_format(const char *str);
int				ft_parse_fov(char *str);
void			**ft_alloc_arraystruc(int count, size_t type_size);
void			ft_free_arraystruc(void **arr, int count);
void			ft_free_scene(t_scene *scene);
void			ft_free_split(char **arr);
void			*ft_get_obj(t_obj_type type, char *line);
t_obj_type		ft_get_type(char *line);
char			*ft_tab_to_space(char *str);
void			ft_free_objects_struc(t_object **arr, int count);

// ============ Vectors ============
t_vec3			vec3_add(t_vec3 vec1, t_vec3 vec2);
t_vec3			atovec3(char **vec);
bool			vec3_cmp(t_vec3 vec1, t_vec3 vec2);
double			vec3_cos(t_vec3 vec1, t_vec3 vec2);
t_vec3			vec3_cross(t_vec3 vec1, t_vec3 vec2);
double			vec3_dot(t_vec3 vec1, t_vec3 vec2);
double			vec3_len(t_vec3 vec);
t_vec3			vec3_new(double x, double y, double z);
t_vec3  		vec3_normalize(t_vec3 vec);
t_vec3			vec3_scale(t_vec3 vec1, double scalar);
t_vec3  		vec3_sub(t_vec3 vec1, t_vec3 vec2);

#endif
