/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minirt.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:42:30 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/15 17:53:27 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINIRT_H
# define MINIRT_H

# include "libft.h"
# include <stdbool.h>
# include <math.h>
# include "../minilibx-linux/mlx.h"
# include "../X11/X.h"
# include "../X11/keysym.h"

# define M_PI	3.14159265358979323846
# define ERROR_PARAM "Error\nUsage: ./minirt <file.rt>"
# define ERROR_FILE "Error\nCannot open this found."
# define ERROR_MALLOC "Error\nCannot allocate memmory."
# define ERROR_SCENE "Error\ninvalid scene."
# define WIDTH 1400
# define HEIGHT 800

# define KEYPRESS        2
# define KEYRELEASE      3
# define BUTTONPRESS     4
# define BUTTONRELEASE   5
# define MOTIONNOTIFY    6
# define DESTROYNOTIFY   17
# define EXPOSE          12

# define KEYPRESSMASK    (1L<<0)
# define KEYRELEASEMASK  (1L<<1)
# define BUTTONPRESSMASK (1L<<2)
# define STRUCNOTIFYMASK (1L<<17) 

typedef struct s_vec3
{
	double	x;
	double	y;
	double	z;
}	t_vec3;

typedef struct s_camdata
{
	t_vec3	forward;
	t_vec3	right;
	t_vec3	up;
	double	fov_rad;
	double	viewport_width;
	double	viewport_height;
}	t_camdata;

typedef struct s_args
{
	char	*ambient_light;
	char	*camera;
	char	**light;
	int		light_count;
	char	**objects;
	int		obj_count;
}	t_args;

typedef struct s_rgb
{
	int	r;
	int	g;
	int	b;
}	t_rgb;

typedef struct s_ambient_light
{
	double	ratio;
	t_rgb	color;
}	t_ambient_light;

typedef struct s_camera
{
	t_vec3		position;
	t_vec3		vector;
	t_camdata	camdata;
	int			fov;
}	t_camera;

typedef struct s_light
{
	t_vec3	position;
	double	ratio;
	t_rgb	color;
}	t_light;

typedef struct s_sphere
{
	t_vec3	center;
	double	diameter;
	t_rgb	color;
}	t_sphere;

typedef struct s_plane
{
	t_vec3	point;
	t_vec3	normal;
	t_rgb	color;
}	t_plane;

typedef struct s_cylinder
{
	t_vec3	center;
	t_vec3	normal;
	double	diameter;
	double	height;
	t_rgb	color;
}	t_cylinder;

typedef enum e_obj_type
{
	SPHERE,
	PLANE,
	CYLINDER,
	INVALID
}	t_obj_type;

typedef struct s_object
{
	t_obj_type	type;
	void		*data;
}	t_object;

typedef struct s_graphics
{
	void	*mlx;
	void	*win;
	void	*img;
	char	*addr;
	int		height;
	int		width;
	int		bpp;
	int		line_length;
	int		endian;
}	t_graphics;

typedef struct s_scene
{
	t_ambient_light	*ambient;
	t_camera		*camera;
	t_light			**lights;
	int				light_count;
	t_object		**objects;
	int				object_count;
	t_graphics		disp;

}	t_scene;

typedef struct s_ray
{
	t_vec3	origin;
	t_vec3	direction;
}	t_ray;

// -----Object intersection

typedef struct s_hcy
{
	t_vec3	oc;
	t_vec3	d;
	t_vec3	n;
	double	a;
	double	b;
	double	c;
	double	discr;
}	t_cycalc;

typedef struct s_hsp
{
	t_vec3	oc;
	double	a;
	double	b;
	double	c;
	double	delta;
	double	sqrt_d;
	double	t0;
	double	t1;

}	t_hsp;

typedef struct s_hit
{
	double		t;
	void		*object;
	int			type;
}	t_hit;

typedef struct s_sphere_hit
{
	t_vec3	oc;
	double	a;
	double	b;
	double	c;
	double	delta;
	double	sqrt_d;
	double	t0;
	double	t1;
}	t_sphere_hit;

typedef struct s_cylinder_hit
{
	t_vec3	oc;
	t_vec3	d;
	t_vec3	w;
	double	a;
	double	b;
	double	c;
	double	discriminant;
	double	t1;
	double	t2;
	t_vec3	p;
	double	h;
}	t_cylinder_hit;

// typedef struct s_world
// {
// 	t_camera	camera;
// 	t_light		ambient;
// 	t_vec3		*lights;
// 	t_vec3		*shapes;
// 	int			counters[3];
// 	t_graphics	disp;
// 	t_vec3		up;
// 	t_vec3		right;
// 	char		**map;
// 	double		hview;
// 	double		wview;
// }	t_world;

// ============ Parser ============

void			ft_exit(char *message, int code);
int				ft_is_rt(char *file);
t_scene			*ft_get_scene(char *file);
int				ft_get_fd(char *file);
void			ft_put_argument(t_args *args, int fd);
void			init_counts(t_args *args, int *count);
void			ft_free_args(t_args *args);
t_scene			*ft_parser(t_args *args);
t_args			*ft_allocate_args(char *file);
char			*ft_is_double(t_args *args, char *target, char *line, int fd);
char			*free_and_getline(char *line, char *trimmed, int fd);
t_ambient_light	*ft_parser_al(char *input);
t_camera		*ft_parser_c(char *input);
t_light			**ft_parser_l(char **input, int count_light);
t_object		**ft_parser_ob(char **input, int count_objects);
t_rgb			ft_get_rgb(char *str);
int				ft_parser_rgb(char *str);
t_camera		*ft_parser_c(char *input);
int				ft_parser_ratio(char *str, double min, double max);
int				ft_is_normalized(char *str);
int				ft_is_number(char *str);
int				ft_parser_vec3(char *str);
t_vec3			ft_get_vec3(char *str);
int				ft_float_format(const char *str);
int				ft_parse_fov(char *str);
void			**ft_alloc_arraystruc(int count, size_t type_size);
void			ft_free_arraystruc(void **arr, int count);
void			ft_free_scene(t_scene *scene);
void			ft_free_object(t_object *obj);
void			ft_free_split(char **arr);
void			*ft_get_obj(t_obj_type type, char *line);
t_obj_type		ft_get_type(char *line);
char			*ft_tab_to_space(char *str);
void			ft_free_objects_struc(t_object **arr, int count);

// ============ Vectors ============

t_vec3			vec3_add(t_vec3 vec1, t_vec3 vec2);
t_vec3			atovec3(char **vec);
bool			vec3_cmp(t_vec3 vec1, t_vec3 vec2);
double			vec3_cos(t_vec3 vec1, t_vec3 vec2);
t_vec3			vec3_cross(t_vec3 vec1, t_vec3 vec2);
double			vec3_dot(t_vec3 vec1, t_vec3 vec2);
double			vec3_len(t_vec3 vec);
t_vec3			vec3_new(double x, double y, double z);
t_vec3			vec3_normalize(t_vec3 vec);
t_vec3			vec3_scale(t_vec3 vec1, double scalar);
t_vec3			vec3_sub(t_vec3 vec1, t_vec3 vec2);

// ============ ray ============
t_camdata		ft_compute_camera(t_camera cam, int width, int height);
t_ray			ft_ray(t_vec3 o, t_vec3 d);
t_ray			make_ray(int x, int y, t_scene *scene);

// ==== object intersection ====
bool			hit_cylinder(t_ray ray, t_cylinder *cy, double *t);
bool			hit_plane(t_ray ray, t_plane *pl, double *t);
bool			hit_sphere(t_ray ray, t_sphere *sp, double *t);
bool			hit_objects(t_scene *scene, t_ray ray, t_hit *hit);

// ==== lighting ====
t_rgb			apply_ambient(t_scene *sc, t_rgb obj_color);
bool			is_in_shadow(t_scene *sc, t_vec3 point, t_light *light);
t_rgb			apply_diffuse(t_vec3 normal, t_vec3 light_dir,
							t_light *light, t_rgb obj_color);
t_rgb			rgb_add(t_rgb a, t_rgb b);
t_rgb			rgb_clamp(t_rgb c);
int				rgb_to_int(t_rgb color);
t_rgb			shade_hit(t_scene *sc, t_hit *hit, t_vec3 point, t_vec3 normal);

// ==== normal ====
t_vec3			get_normal(t_hit *hit, t_vec3 point);

// ==== render ====
void			put_pixel(t_scene *scene, int x, int y, int color);
void  			render_scene(t_scene *scene);

// ==== graphics ====
int				key_press(int keycode, t_scene *scene);
int				close_window(t_scene *scene);
void			ft_init_graphics(t_scene *scene);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   events.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 19:42:38 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/14 14:29:00 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

int	close_window(t_scene *scene)
{
	void	*mlx_ptr;
	void	*win_ptr;
	void	*img_ptr;

	if (!scene)
		exit(0);
	mlx_ptr = scene->disp.mlx;
	win_ptr = scene->disp.win;
	img_ptr = scene->disp.img;
	if (img_ptr && mlx_ptr)
		mlx_destroy_image(mlx_ptr, img_ptr);
	if (win_ptr && mlx_ptr)
		mlx_destroy_window(mlx_ptr, win_ptr);
	ft_free_scene(scene);
	if (mlx_ptr)
	{
		mlx_destroy_display(mlx_ptr);
		free(mlx_ptr);
	}
	exit(0);
	return (0);
}

int	key_press(int keycode, t_scene *scene)
{
	if (keycode == 65307)
		close_window(scene);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minilibx_setup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/01 19:33:59 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/14 20:08:37 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

static void	ft_mlx_destroy_all(t_scene *scene)
{
	if (scene->disp.img)
		mlx_destroy_image(scene->disp.mlx, scene->disp.img);
	if (scene->disp.win)
		mlx_destroy_window(scene->disp.mlx, scene->disp.win);
	if (scene->disp.mlx)
	{
		mlx_destroy_display(scene->disp.mlx);
		free(scene->disp.mlx);
	}
}

static void	ft_mlx_fatal(t_scene *scene, char *msg)
{
	ft_mlx_destroy_all(scene);
	ft_free_scene(scene);
	ft_exit(msg, 1);
}

void	ft_init_graphics(t_scene *scene)
{
	scene->disp.width = WIDTH;
	scene->disp.height = HEIGHT;
	scene->disp.mlx = mlx_init();
	if (!scene->disp.mlx)
		ft_mlx_fatal(scene, "Error: MLX initialization failed");
	scene->disp.win = mlx_new_window(scene->disp.mlx, WIDTH, HEIGHT, "miniRT");
	if (!scene->disp.win)
		ft_mlx_fatal(scene, "Error: Window creation failed");
	scene->disp.img = mlx_new_image(scene->disp.mlx, WIDTH, HEIGHT);
	if (!scene->disp.img)
		ft_mlx_fatal(scene, "Error: Image creation failed");
	scene->disp.addr = mlx_get_data_addr(scene->disp.img,
			&scene->disp.bpp,
			&scene->disp.line_length,
			&scene->disp.endian);
	if (!scene->disp.addr)
		ft_mlx_fatal(scene, "Error: Image address failed");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ambiente_light.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 14:50:40 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 15:14:11 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_rgb	apply_ambient(t_scene *sc, t_rgb obj_color)
{
	t_rgb	res;

	res.r = obj_color.r * sc->ambient->ratio * (sc->ambient->color.r / 255.0);
	res.g = obj_color.g * sc->ambient->ratio * (sc->ambient->color.g / 255.0);
	res.b = obj_color.b * sc->ambient->ratio * (sc->ambient->color.b / 255.0);
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   diffuse.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 14:51:58 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 14:58:31 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_rgb	apply_diffuse(t_vec3 normal, t_vec3 light_dir,
							t_light *light, t_rgb obj_color)
{
	double	diff;
	t_rgb	res;

	diff = vec3_dot(normal, light_dir);
	if (diff < 0)
		diff = 0;
	res.r = obj_color.r * diff * light->ratio * (light->color.r / 255.0);
	res.g = obj_color.g * diff * light->ratio * (light->color.g / 255.0);
	res.b = obj_color.b * diff * light->ratio * (light->color.b / 255.0);
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shade_hit.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 14:57:47 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 15:12:05 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_rgb	shade_hit(t_scene *sc, t_hit *hit, t_vec3 point, t_vec3 normal)
{
	t_rgb	color;
	t_rgb	tmp;
	int		i;
	t_rgb	obj_color;

	if (hit->type == SPHERE)
		obj_color = ((t_sphere *)hit->object)->color;
	else if (hit->type == PLANE)
		obj_color = ((t_plane *)hit->object)->color;
	else
		obj_color = ((t_cylinder *)hit->object)->color;
	color = apply_ambient(sc, obj_color);
	i = 0;
	while (i < sc->light_count)
	{
		if (!is_in_shadow(sc, point, sc->lights[i]))
		{
			tmp = apply_diffuse(normal,
					vec3_normalize(vec3_sub(sc->lights[i]->position, point)),
					sc->lights[i], obj_color);
			color = rgb_add(color, tmp);
		}
		i++;
	}
	return (rgb_clamp(color));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_lighting.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 14:55:04 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/14 14:57:36 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

bool	is_in_shadow(t_scene *sc, t_vec3 point, t_light *light)
{
	t_ray	shadow;
	t_hit	tmp;
	t_vec3	to_light;
	double	dist;

	to_light = vec3_sub(light->position, point);
	dist = vec3_len(to_light);
	to_light = vec3_normalize(to_light);
	shadow.origin = vec3_add(point, vec3_scale(to_light, 1e-4));
	shadow.direction = to_light;
	if (hit_objects(sc, shadow, &tmp))
	{
		if (tmp.t > 1e-6 && tmp.t < dist)
			return (true);
	}
	return (false);
}

t_rgb	rgb_add(t_rgb a, t_rgb b)
{
	t_rgb	c;

	c.r = a.r + b.r;
	c.g = a.g + b.g;
	c.b = a.b + b.b;
	return (c);
}

t_rgb	rgb_clamp(t_rgb c)
{
	if (c.r > 255)
		c.r = 255;
	if (c.g > 255)
		c.g = 255;
	if (c.b > 255)
		c.b = 255;
	if (c.r < 0)
		c.r = 0;
	if (c.g < 0)
		c.g = 0;
	if (c.b < 0)
		c.b = 0;
	return (c);
}

int	rgb_to_int(t_rgb color)
{
	int	r;
	int	g;
	int	b;

	r = (int)color.r;
	g = (int)color.g;
	b = (int)color.b;
	if (r < 0)
		r = 0;
	if (r > 255)
		r = 255;
	if (g < 0)
		g = 0;
	if (g > 255)
		g = 255;
	if (b < 0)
		b = 0;
	if (b > 255)
		b = 255;
	return (r << 16 | g << 8 | b);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   0-main.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:44:29 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/14 14:38:32 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

int	main(int argc, char **argv)
{
	t_scene	*scene;

	if (argc != 2 || ft_is_rt(argv[1]))
		ft_exit(ERROR_PARAM, 1);
	scene = ft_get_scene(argv[1]);
	if (!scene)
		ft_exit("Error: Failed to parse scene", 1);
	ft_init_graphics(scene);
	render_scene(scene);
	mlx_hook(scene->disp.win, 2, 1l << 0, key_press, scene);
	mlx_hook(scene->disp.win, 17, 1L << 17, close_window, scene);
	mlx_loop(scene->disp.mlx);
	return (0);
}

void	ft_exit(char *message, int code)
{
	if (message)
		ft_putendl_fd(message, 2);
	exit(code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   1-get_args.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 16:20:41 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/18 15:39:00 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// 1 - fill Args struct with user input
// 2 - Arguments Parser, if all is ok, return struct scene
t_scene	*ft_get_scene(char *file)
{
	t_args	*args;
	t_scene	*scene;

	args = ft_allocate_args(file);
	scene = ft_parser(args);
	ft_free_args(args);
	return (scene);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   2-allocate.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/15 12:08:27 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/15 17:00:11 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

static int	ft_is_object(char *line)
{
	int	i;

	i = 0;
	if (!line)
		return (0);
	while (line[i] == ' ')
		i++;
	if (!ft_strncmp(&line[i], "sp ", 3))
		return (1);
	if (!ft_strncmp(&line[i], "pl ", 3))
		return (1);
	if (!ft_strncmp(&line[i], "cy ", 3))
		return (1);
	return (0);
}

static void	ft_count_line(char *line, int *count)
{
	char	*trimmed;
	int		i;

	trimmed = ft_strtrim(line, " \t\r\b\n");
	if (!trimmed)
		return ;
	ft_tab_to_space(trimmed);
	i = 0;
	while (trimmed[i] == ' ')
		i++;
	if (!ft_strncmp(&trimmed[i], "L ", 2))
		count[0]++;
	else if (ft_is_object(trimmed))
		count[1]++;
	free(trimmed);
}

static int	*ft_count(char *file)
{
	int		*count;
	int		fd;
	char	*line;

	count = ft_calloc(2, sizeof(int));
	if (!count)
		ft_exit(ERROR_MALLOC, 2);
	fd = ft_get_fd(file);
	line = get_next_line(fd);
	while (line)
	{
		ft_count_line(line, count);
		free(line);
		line = get_next_line(fd);
	}
	close(fd);
	return (count);
}

// 1 - set args NULL
// 2 - strtrim for erase spaces
// 3 - fill scruct according the type of the lines
// 4 - Cam and ambient light can't duplicate
// if invalid argument, call ft_is_double for free and exit
void	ft_put_argument(t_args *args, int fd)
{
	int		i;
	int		k;
	char	*line;
	char	*trimmed;

	i = 0;
	k = 0;
	line = get_next_line(fd);
	while (line)
	{
		trimmed = ft_strtrim(line, " \t\r\b\n");
		ft_tab_to_space(trimmed);
		if (!ft_strncmp(trimmed, "A ", 2))
			args->ambient_light = ft_is_double(args,
					args->ambient_light, trimmed, fd);
		else if (!ft_strncmp(trimmed, "C ", 2))
			args->camera = ft_is_double(args, args->camera, trimmed, fd);
		else if (!ft_strncmp(trimmed, "L ", 2))
			args->light[k++] = ft_strdup(trimmed);
		else if (ft_is_object(trimmed))
			args->objects[i++] = ft_strdup(trimmed);
		else if (trimmed[0] != '\n' && trimmed[0] != '#' && trimmed[0] != '\0')
			ft_is_double(args, "invalid", trimmed, fd);
		line = free_and_getline(line, trimmed, fd);
	}
}

// 1- call ft_count to get number of the Lights and objets
// 2 - allocate memory for struct and arrays-arrays
// 3 - call ft_put_argument to fill struct
t_args	*ft_allocate_args(char *file)
{
	t_args	*args;
	int		*count;
	int		fd;

	count = ft_count(file);
	args = ft_calloc(sizeof(t_args), 1);
	if (!args)
		ft_exit(ERROR_MALLOC, 2);
	init_counts(args, count);
	free(count);
	args->objects = ft_calloc(sizeof(char *), (args->obj_count + 1));
	if (!args->objects)
		ft_exit(ERROR_MALLOC, 2);
	args->objects[args->obj_count] = NULL;
	if (args->light_count > 0)
	{
		args->light = ft_calloc(sizeof(char *), (args->light_count + 1));
		if (!args->light_count)
			ft_exit(ERROR_MALLOC, 2);
		args->objects[args->light_count] = NULL;
	}
	fd = ft_get_fd(file);
	ft_put_argument(args, fd);
	close(fd);
	return (args);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.1-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/19 16:20:22 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 21:25:21 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// verified if all str value is a number
int	ft_is_number(char *str)
{
	int	i;

	i = 0;
	if (!str || !*str)
		return (0);
	while (str[i])
	{
		if (str[i] < '0' || str[i] > '9')
			return (0);
		i++;
	}
	return (1);
}

// 1 - verified if have 3 parts when we split with ","
// 2 - check if each part is a number and if it are between 0 - 255. 
int	ft_parser_rgb(char *str)
{
	char	**s;
	int		i;
	int		value;

	s = ft_split(str, ',');
	if (!s || count_parts(str, ',') != 3)
		return (ft_free_split(s), 0);
	i = -1;
	while (++i < 3)
	{
		if (!ft_is_number(s[i]))
			return (ft_free_split(s), 0);
		value = ft_atoi(s[i]);
		if (value < 0 || value > 255)
			return (ft_free_split(s), 0);
	}
	ft_free_split(s);
	return (1);
}

// 1- call float format for check if the argument is a float
// 2 - check if value are between min and max
int	ft_parser_ratio(char *str, double min, double max)
{
	float	value;

	if (!ft_float_format(str))
		return (0);
	value = ft_atod(str);
	if (value < min || value > max)
		return (0);
	return (1);
}

// 1 - verify if have 3 parts when we split with ",".
// 2 - check if all parts are in float format.
int	ft_parser_vec3(char *str)
{
	char	**p;

	if (!str)
		return (0);
	p = ft_split(str, ',');
	if (!p || count_parts(str, ',') != 3 || !p[0] || !p[1] || !p[2])
	{
		ft_free_split(p);
		return (0);
	}
	if (!ft_float_format(p[0])
		|| !ft_float_format(p[1])
		|| !ft_float_format(p[2]))
	{
		ft_free_split(p);
		return (0);
	}
	ft_free_split(p);
	return (1);
}

// 1 - call parser vec3 for verify if str is a vector with 3 argument
// 2 - call parser ratio, check if is a float and between -1 and 1.
int	ft_is_normalized(char *str)
{
	char	**args;
	double	x;
	double	y;
	double	z;

	if (!ft_parser_vec3(str))
		return (0);
	args = ft_split(str, ',');
	if (!args)
		return (0);
	if (!ft_parser_ratio(args[0], -1, 1)
		|| !ft_parser_ratio(args[1], -1, 1)
		|| !ft_parser_ratio(args[2], -1, 1))
	{
		ft_free_split(args);
		return (0);
	}
	x = ft_atod(args[0]);
	y = ft_atod(args[1]);
	z = ft_atod(args[2]);
	ft_free_split(args);
	if (x == 0.0 && y == 0.0 && z == 0.0)
		return (0);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.2-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 14:13:09 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/15 17:00:18 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// verify if is a float and if are between 0 - 180.
int	ft_parse_fov(char *str)
{
	float	fov;

	if (!ft_float_format(str))
		return (0);
	fov = ft_atod(str);
	if (fov < 0 || fov > 180)
		return (0);
	return (1);
}

// verify if is a digit and if have 0 or 1 point
static int	ft_float_format_util(const char *str)
{
	int	i;
	int	digits;
	int	dots;

	i = 0;
	digits = 0;
	dots = 0;
	while (str[i])
	{
		if (str[i] >= '0' && str[i] <= '9')
			digits++;
		else if (str[i] == '.')
		{
			if (++dots > 1 || !str[i + 1])
				return (0);
		}
		else
			return (0);
		i++;
	}
	return (digits > 0);
}

// verify if have a signal, and call util
int	ft_float_format(const char *str)
{
	int	i;

	if (!str || !*str)
		return (0);
	i = 0;
	if (str[i] == '+' || str[i] == '-')
		i++;
	if (!str[i])
		return (0);
	return (ft_float_format_util(&str[i]));
}

// used for free scructs
void	**ft_alloc_arraystruc(int count, size_t type_size)
{
	void	**arr;
	int		i;

	if (count <= 0)
		return (NULL);
	arr = ft_calloc(count + 1, sizeof(void *));
	if (!arr)
		return (NULL);
	i = 0;
	while (i < count)
	{
		arr[i] = ft_calloc(1, type_size);
		if (!arr[i])
		{
			while (--i >= 0)
				free(arr[i]);
			free(arr);
			return (NULL);
		}
		i++;
	}
	arr[count] = NULL;
	return (arr);
}

char	*ft_is_double(t_args *args, char *target, char *line, int fd)
{
	if (target)
	{
		free(line);
		ft_free_args(args);
		close(fd);
		ft_exit(ERROR_SCENE, 2);
	}
	return (ft_strdup(line));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.3-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/19 17:02:49 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/02 15:34:36 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// split str and return struct RGB.
t_rgb	ft_get_rgb(char *str)
{
	t_rgb	rgb;
	char	**vals;

	vals = ft_split(str, ',');
	rgb.r = ft_atoi(vals[0]);
	rgb.g = ft_atoi(vals[1]);
	rgb.b = ft_atoi(vals[2]);
	ft_free_split(vals);
	return (rgb);
}

// return a vector with 3 values.
t_vec3	ft_get_vec3(char *str)
{
	t_vec3	v;
	char	**parts;

	parts = ft_split(str, ',');
	v.x = ft_atod(parts[0]);
	v.y = ft_atod(parts[1]);
	v.z = ft_atod(parts[2]);
	ft_free_split(parts);
	return (v);
}

// translate \t to ' '
char	*ft_tab_to_space(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (str[i] == '\t')
			str[i] = ' ';
		i++;
	}
	return (str);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.4-parser_obj_utils.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 16:55:35 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/15 17:21:34 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

void	*ft_parser_sphere(char *line)
{
	t_sphere	*sp;
	char		**args;

	if (count_parts(line, ' ') != 4)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "sp", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_float_format(args[2])
		|| !ft_parser_rgb(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	sp = ft_calloc(1, sizeof(t_sphere));
	sp->center = ft_get_vec3(args[1]);
	sp->diameter = ft_atod(args[2]);
	sp->color = ft_get_rgb(args[3]);
	ft_free_split(args);
	return (sp);
}

void	*ft_parser_plane(char *line)
{
	t_plane	*pl;
	char	**args;

	if (count_parts(line, ' ') != 4)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "pl", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_parser_rgb(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	pl = ft_calloc(1, sizeof(t_plane));
	pl->point = ft_get_vec3(args[1]);
	pl->normal = ft_get_vec3(args[2]);
	pl->normal = vec3_normalize(pl->normal);
	pl->color = ft_get_rgb(args[3]);
	ft_free_split(args);
	return (pl);
}

void	*ft_parser_cylinder(char *line)
{
	t_cylinder	*cy;
	char		**args;

	if (count_parts(line, ' ') != 6)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "cy", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_float_format(args[3])
		|| !ft_float_format(args[4])
		|| !ft_parser_rgb(args[5]))
		return (ft_free_split(args), NULL);
	cy = ft_calloc(1, sizeof(t_cylinder));
	cy->center = ft_get_vec3(args[1]);
	cy->normal = ft_get_vec3(args[2]);
	cy->normal = vec3_normalize(cy->normal);
	cy->diameter = ft_atod(args[3]);
	cy->height = ft_atod(args[4]);
	cy->color = ft_get_rgb(args[5]);
	ft_free_split(args);
	return (cy);
}

// return struct according to type.
void	*ft_get_obj(t_obj_type type, char *line)
{
	if (type == SPHERE)
		return (ft_parser_sphere(line));
	if (type == PLANE)
		return (ft_parser_plane(line));
	if (type == CYLINDER)
		return (ft_parser_cylinder(line));
	return (NULL);
}

// define the type of the object
t_obj_type	ft_get_type(char *line)
{
	if (!ft_strncmp(line, "sp ", 3))
		return (SPHERE);
	if (!ft_strncmp(line, "pl ", 3))
		return (PLANE);
	if (!ft_strncmp(line, "cy ", 3))
		return (CYLINDER);
	return (INVALID);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.5-parser_l.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/14 16:30:56 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/14 16:32:44 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

static int	is_valid_light_line(char *line)
{
	char	**args;

	if (count_parts(line, ' ') != 4)
		return (0);
	args = ft_split(line, ' ');
	if (!args || !args[0] || !args[1] || !args[2] || !args[3]
		|| ft_strncmp(args[0], "L", ft_strlen(args[0])) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_parser_ratio(args[2], 0, 1)
		|| !ft_parser_rgb(args[3]))
	{
		ft_free_split(args);
		return (0);
	}
	ft_free_split(args);
	return (1);
}

static void	fill_light(t_light *light, char *line)
{
	char	**args;

	args = ft_split(line, ' ');
	light->position = ft_get_vec3(args[1]);
	light->ratio = ft_atod(args[2]);
	light->color = ft_get_rgb(args[3]);
	ft_free_split(args);
}

t_light	**ft_parser_l(char **input, int count_light)
{
	t_light	**light;
	int		i;

	light = (t_light **)ft_alloc_arraystruc(count_light, sizeof(t_light));
	if (!light)
		return (NULL);
	i = 0;
	while (i < count_light && input[i])
	{
		if (!is_valid_light_line(input[i]))
			return (ft_free_arraystruc((void **)light, count_light), NULL);
		fill_light(light[i], input[i]);
		i++;
	}
	return (light);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3-parser.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/15 12:38:39 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/14 16:31:14 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_scene	*ft_parser(t_args *args)
{
	t_scene	*scene;

	scene = ft_calloc(sizeof(t_scene), 1);
	scene->light_count = args->light_count;
	scene->object_count = args->obj_count;
	scene->ambient = ft_parser_al(args->ambient_light);
	scene->camera = ft_parser_c(args->camera);
	scene->lights = ft_parser_l(args->light, scene->light_count);
	scene->objects = ft_parser_ob(args->objects, scene->object_count);
	if (scene->ambient == NULL || scene->camera == NULL
		|| (scene->light_count > 0 && scene->lights == NULL)
		|| (scene->objects == NULL))
	{
		ft_free_args(args);
		ft_free_scene(scene);
		ft_exit(ERROR_SCENE, 2);
	}
	scene->camera->camdata = ft_compute_camera(*scene->camera, WIDTH, HEIGHT);
	return (scene);
}

// 1 - count parts to verified if have 3 arguments.
// 2 - if with 3 condictions:
//		first argument is 'A'.
//			parser ratio, if arguments is a float 0.0 - 1.0.
//				parser RGB xxx,xxx,xxx.
// 3 - strdup and get rgb for allocate arguments.
t_ambient_light	*ft_parser_al(char *input)
{
	t_ambient_light	*al;
	char			**args;

	if (count_parts(input, ' ') != 3)
		return (NULL);
	args = ft_split(input, ' ');
	if (ft_strncmp(args[0], "A", ft_strlen(args[0])) != 0
		|| !ft_parser_ratio(args[1], 0.0, 1.0)
		|| !ft_parser_rgb(args[2]))
	{
		ft_free_split(args);
		return (NULL);
	}
	al = ft_calloc(sizeof(t_ambient_light), 1);
	al->ratio = ft_atod(args[1]);
	al->color = ft_get_rgb(args[2]);
	ft_free_split(args);
	return (al);
}

t_camera	*ft_parser_c(char *input)
{
	t_camera	*camera;
	char		**args;

	if (count_parts(input, ' ') != 4)
		return (NULL);
	args = ft_split(input, ' ');
	if (ft_strncmp(args[0], "C", ft_strlen(args[0])) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_parse_fov(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	camera = ft_calloc(sizeof(t_camera), 1);
	camera->position = ft_get_vec3(args[1]);
	camera->vector = ft_get_vec3(args[2]);
	camera->fov = ft_atod(args[3]);
	ft_free_split(args);
	return (camera);
}

t_object	**ft_parser_ob(char **input, int count_objects)
{
	t_object	**objects;
	int			i;

	if (!input || count_objects <= 0)
		return (NULL);
	objects = (t_object **)ft_alloc_arraystruc(count_objects, sizeof(t_object));
	if (!objects)
		return (NULL);
	i = 0;
	while (i < count_objects)
	{
		if (!input[i])
			break ;
		objects[i]->type = ft_get_type(input[i]);
		if (objects[i]->type == INVALID)
			return (ft_free_objects_struc(objects, count_objects), NULL);
		objects[i]->data = ft_get_obj(objects[i]->type, input[i]);
		if (objects[i]->data == NULL)
			return (ft_free_objects_struc(objects, count_objects), NULL);
		i++;
	}
	return (objects);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_functions1.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 16:13:14 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/15 16:42:57 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"
/*this file have free functions.*/

void	ft_free_arraystruc(void **arr, int count)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (i < count)
	{
		if (arr[i])
			free(arr[i]);
		i++;
	}
	free(arr);
}

void	ft_free_scene(t_scene *scene)
{
	int	i;

	if (!scene)
		return ;
	if (scene->ambient)
		free(scene->ambient);
	if (scene->camera)
		free(scene->camera);
	if (scene->lights)
	{
		i = 0;
		while (i < scene->light_count)
		{
			if (scene->lights[i])
				free(scene->lights[i]);
			i++;
		}
		free(scene->lights);
	}
	if (scene->objects)
		ft_free_objects_struc(scene->objects, scene->object_count);
	free(scene);
}

void	ft_free_object(t_object *obj)
{
	if (!obj)
		return ;
	if (obj->data)
	{
		if (obj->type == SPHERE)
			free((t_sphere *)obj->data);
		else if (obj->type == PLANE)
			free((t_plane *)obj->data);
		else if (obj->type == CYLINDER)
			free((t_cylinder *)obj->data);
	}
	free(obj);
}

void	ft_free_objects_struc(t_object **arr, int count)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (i < count)
	{
		if (arr[i])
			ft_free_object(arr[i]);
		i++;
	}
	free(arr);
}

char	*free_and_getline(char *line, char *trimmed, int fd)
{
	free(trimmed);
	free(line);
	return (line = get_next_line(fd));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_functions.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:46:12 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/15 16:37:45 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

int	ft_is_rt(char *file)
{
	size_t	len;

	if (!file)
		return (1);
	len = ft_strlen(file);
	if (len < 3)
		return (1);
	if (ft_strncmp(file + len - 3, ".rt", 3) != 0)
		return (1);
	return (0);
}

int	ft_get_fd(char *file)
{
	int	fd;

	fd = open(file, O_RDONLY);
	if (fd < 0)
		ft_exit(ERROR_FILE, 2);
	return (fd);
}

void	ft_free_split(char **arr)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

void	ft_free_args(t_args *args)
{
	if (args->ambient_light)
		free(args->ambient_light);
	if (args->camera)
		free(args->camera);
	if (args->light)
		ft_free_split(args->light);
	if (args->objects)
		ft_free_split(args->objects);
	free(args);
}

void	init_counts(t_args *args, int *count)
{
	args->ambient_light = NULL;
	args->camera = NULL;
	args->light_count = count[0];
	args->obj_count = count[1];
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cam_data.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/02 16:42:02 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 21:16:53 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_camdata	ft_compute_camera(t_camera cam, int width, int height)
{
	t_camdata	c;
	t_vec3		world_up;

	world_up = ft_get_vec3("0,1,0");
	c.forward = vec3_normalize(cam.vector);
	if (fabs(vec3_dot(c.forward, world_up)) > 0.999)
		world_up = ft_get_vec3("0,0,1");
	c.right = vec3_normalize(vec3_cross(c.forward, world_up));
	c.up = vec3_cross(c.right, c.forward);
	c.fov_rad = cam.fov * M_PI / 180.0;
	c.viewport_height = 2 * tan(c.fov_rad / 2);
	c.viewport_width = c.viewport_height * ((double)width / height);
	return (c);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ray.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/03 15:41:55 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 20:57:08 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_ray	ft_ray(t_vec3 o, t_vec3 d)
{
	t_ray	r;

	r.origin = o;
	r.direction = vec3_normalize(d);
	return (r);
}

t_ray	make_ray(int x, int y, t_scene *scene)
{
	double	u;
	double	v;
	t_vec3	pixel_dir;

	u = (double)x / (WIDTH - 1);
	v = (double)y / (HEIGHT - 1);
	u = u - 0.5;
	v = 0.5 - v;
	pixel_dir = vec3_add(vec3_add(
				vec3_scale(scene->camera->camdata.right,
					u * scene->camera->camdata.viewport_width),
				vec3_scale(scene->camera->camdata.up,
					v * scene->camera->camdata.viewport_height)),
			scene->camera->camdata.forward);
	return (ft_ray(scene->camera->position, pixel_dir));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   normal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 19:01:14 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/14 14:57:33 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// dist_to_base = 0, dist_to_top = 1
static t_vec3	get_cylinder_normal(t_hit *hit, t_vec3 point)
{
	t_cylinder	*cy;
	t_vec3		to_point;
	double		proj;
	t_vec3		point_on_axis;
	double		dist[2];

	cy = (t_cylinder *)hit->object;
	to_point = vec3_sub(point, cy->center);
	proj = vec3_dot(to_point, cy->normal);
	dist[0] = fabs(proj);
	dist[1] = fabs(proj - cy->height);
	if (dist[0] < 1e-4)
		return (vec3_scale(cy->normal, -1.0));
	if (dist[1] < 1e-4)
		return (cy->normal);
	point_on_axis = vec3_add(cy->center, vec3_scale(cy->normal, proj));
	return (vec3_normalize(vec3_sub(point, point_on_axis)));
}

t_vec3	get_normal(t_hit *hit, t_vec3 point)
{
	t_vec3		normal;
	t_sphere	*sp;
	t_plane		*pl;

	if (hit->type == SPHERE)
	{
		sp = (t_sphere *)hit->object;
		normal = vec3_normalize(vec3_sub(point, sp->center));
	}
	else if (hit->type == PLANE)
	{
		pl = (t_plane *)hit->object;
		normal = vec3_normalize(pl->normal);
	}
	else if (hit->type == CYLINDER)
		normal = get_cylinder_normal(hit, point);
	else
		normal = vec3_new(0, 1, 0);
	return (normal);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 18:48:20 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/14 18:28:51 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

static t_rgb	compute_pixel_color(t_scene *scene, int x, int y)
{
	t_ray	ray;
	t_hit	hit;
	t_vec3	point;
	t_vec3	normal;

	ray = make_ray(x, y, scene);
	if (!hit_objects(scene, ray, &hit))
		return ((t_rgb){0, 0, 0});
	point = vec3_add(ray.origin, vec3_scale(ray.direction, hit.t));
	normal = get_normal(&hit, point);
	return (shade_hit(scene, &hit, point, normal));
}

static void	render_row(t_scene *scene, int y)
{
	int		x;
	t_rgb	color;

	x = 0;
	while (x < WIDTH)
	{
		color = compute_pixel_color(scene, x, y);
		put_pixel(scene, x, y, rgb_to_int(color));
		x++;
	}
}

static void	display_image(t_scene *scene)
{
	if (scene->disp.mlx && scene->disp.win && scene->disp.img)
		mlx_put_image_to_window(scene->disp.mlx,
			scene->disp.win, scene->disp.img, 0, 0);
}

void	render_scene(t_scene *scene)
{
	int	y;

	y = 0;
	while (y < HEIGHT)
	{
		render_row(scene, y);
		y++;
	}
	display_image(scene);
}

void	put_pixel(t_scene *scene, int x, int y, int color)
{
	char	*dst;

	if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
		return ;
	dst = scene->disp.addr + (y * scene->disp.line_length
			+ x * (scene->disp.bpp / 8));
	*(unsigned int *)dst = color;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_add.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:46:45 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:19:19 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_add(t_vec3 vec1, t_vec3 vec2)
{
	return (vec3_new(vec1.x + vec2.x, vec1.y + vec2.y, vec1.z + vec2.z));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_atovec3.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:18:28 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:22:44 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	atovec3(char **vec)
{
	return ((t_vec3)
		{
			.x = ft_atod(vec[0]),
			.y = ft_atod(vec[1]),
			.z = ft_atod(vec[2]),
		}
	);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_cmp.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:54:32 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:19:47 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

bool	vec3_cmp(t_vec3 vec1, t_vec3 vec2)
{
	return (vec1.x == vec2.x && vec1.y == vec2.y && vec1.z == vec2.z);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_cos.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:58:24 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:20:24 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

double	vec3_cos(t_vec3 vec1, t_vec3 vec2)
{
	double	dot;
	double	len;

	dot = vec3_dot(vec1, vec2);
	len = vec3_len(vec1) * vec3_len(vec2);
	return (dot / len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_cross.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:59:59 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/13 19:09:19 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_cross(t_vec3 vec1, t_vec3 vec2)
{
	t_vec3	res;

	res.x = vec1.y * vec2.z - vec1.z * vec2.y;
	res.y = vec1.z * vec2.x - vec1.x * vec2.z;
	res.z = vec1.x * vec2.y - vec1.y * vec2.x;
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_dot.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:04:13 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:20:34 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

double	vec3_dot(t_vec3 vec1, t_vec3 vec2)
{
	return (vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_len.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:12:11 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:20:44 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

double	vec3_len(t_vec3 vec)
{
	return (sqrt(pow(vec.x, 2) + pow(vec.y, 2) + pow(vec.z, 2)));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_new.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:44:22 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:20:53 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_new(double x, double y, double z)
{
	return ((t_vec3){x, y, z});
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_normalize.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:28:05 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/13 21:16:31 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_normalize(t_vec3 vec)
{
	double	len;

	len = vec3_len(vec);
	if (len < 1e-10)
		return (vec3_new(0, 0, 1));
	return (vec3_scale(vec, 1.0 / len));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_scale.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:29:21 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:21:18 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_scale(t_vec3 vec1, double scalar)
{
	return (vec3_new(vec1.x * scalar, vec1.y * scalar, vec1.z * scalar));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_sub.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:35:48 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:21:26 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_sub(t_vec3 vec1, t_vec3 vec2)
{
	return (vec3_new(vec1.x - vec2.x, vec1.y - vec2.y, vec1.z - vec2.z));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_cylinder.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/08 15:45:05 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/15 17:52:52 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

#define EPSILON 1e-6
#define INF_VAL 1e30

static bool	cy_lateral(t_ray ray, t_cylinder *cy, double *out);
static bool	cy_cap(t_ray ray, t_cylinder *cy, double *out, int top);

bool	hit_cylinder(t_ray ray, t_cylinder *cy, double *t)
{
	double	t_lateral;
	double	t_top;
	double	t_bottom;
	bool	hit;

	t_lateral = INF_VAL;
	t_top = INF_VAL;
	t_bottom = INF_VAL;
	hit = false;
	if (cy_lateral(ray, cy, &t_lateral))
		hit = true;
	if (cy_cap(ray, cy, &t_top, 1))
		hit = true;
	if (cy_cap(ray, cy, &t_bottom, 0))
		hit = true;
	if (!hit)
		return (false);
	*t = t_lateral;
	if (t_top < *t && t_top > EPSILON)
		*t = t_top;
	if (t_bottom < *t && t_bottom > EPSILON)
		*t = t_bottom;
	return (true);
}

/*
 * caps: top == 1 -> top cap ; top == 0 -> bottom cap
 * assume cy->center is the base (bottom).
 * top center = center + normal*height
 */
static bool	cy_cap(t_ray ray, t_cylinder *cy, double *out, int top)
{
	t_plane	pl;
	t_vec3	center;
	t_vec3	p;
	double	t;

	if (top)
		center = vec3_add(cy->center, vec3_scale(cy->normal, cy->height));
	else
		center = cy->center;
	pl.point = center;
	pl.normal = cy->normal;
	pl.color = (t_rgb){0, 0, 0};
	if (!hit_plane(ray, &pl, &t))
		return (false);
	if (t < EPSILON)
		return (false);
	p = vec3_add(ray.origin, vec3_scale(ray.direction, t));
	if (vec3_len(vec3_sub(p, center)) <= cy->diameter / 2.0)
	{
		*out = t;
		return (true);
	}
	return (false);
}

static bool	cy_lateral_2(t_ray ray, t_cylinder *cy,
		double *out, t_cylinder_hit hit)
{
	hit.t1 = (-hit.b - sqrt(hit.discriminant)) / (2 * hit.a);
	hit.t2 = (-hit.b + sqrt(hit.discriminant)) / (2 * hit.a);
	if (hit.t1 > EPSILON)
	{
		hit.p = vec3_add(ray.origin, vec3_scale(ray.direction, hit.t1));
		hit.h = vec3_dot(vec3_sub(hit.p, cy->center), cy->normal);
		if (hit.h >= 0.0 && hit.h <= cy->height)
		{
			*out = hit.t1;
			return (true);
		}
	}
	if (hit.t2 > EPSILON)
	{
		hit.p = vec3_add(ray.origin, vec3_scale(ray.direction, hit.t2));
		hit.h = vec3_dot(vec3_sub(hit.p, cy->center), cy->normal);
		if (hit.h >= 0.0 && hit.h <= cy->height)
		{
			*out = hit.t2;
			return (true);
		}
	}
	return (false);
}

/*
typedef struct s_cylinder_hit
{
	t_vec3	oc;
	t_vec3	d;
	t_vec3	w;
	double	a;
	double	b;
	double	c;
	double	discriminant;
	double	t1;
	double	t2;
	t_vec3	p;
	double	h;
}	t_cylinder_hit;*/
static bool	cy_lateral(t_ray ray, t_cylinder *cy, double *out)
{
	t_cylinder_hit	hit;

	hit.oc = vec3_sub(ray.origin, cy->center);
	hit.d = vec3_sub(ray.direction,
			vec3_scale(cy->normal, vec3_dot(ray.direction, cy->normal)));
	hit.w = vec3_sub(hit.oc, vec3_scale(cy->normal,
				vec3_dot(hit.oc, cy->normal)));
	hit.a = vec3_dot(hit.d, hit.d);
	hit.b = 2 * vec3_dot(hit.d, hit.w);
	hit.c = vec3_dot(hit.w, hit.w) - (cy->diameter * cy->diameter) / 4.0;
	hit.discriminant = hit.b * hit.b - 4 * hit.a * hit.c;
	if (hit.discriminant < 0.0 || fabs(hit.a) < EPSILON)
		return (false);
	return (cy_lateral_2(ray, cy, out, hit));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_objects.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/10 15:39:35 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/14 16:27:56 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

static void	update_hit(t_hit *hit, double t, t_object *obj, int type)
{
	hit->t = t;
	hit->object = obj->data;
	hit->type = type;
}

static int	is_valid_t(double t, double current)
{
	if (t > 1e-6 && t < current)
		return (1);
	return (0);
}

static void	test_object(t_object *obj, t_ray ray, t_hit *hit)
{
	double	t;

	if (obj->type == SPHERE
		&& hit_sphere(ray, (t_sphere *)obj->data, &t)
		&& is_valid_t(t, hit->t))
		update_hit(hit, t, obj, SPHERE);
	else if (obj->type == PLANE
		&& hit_plane(ray, (t_plane *)obj->data, &t)
		&& is_valid_t(t, hit->t))
		update_hit(hit, t, obj, PLANE);
	else if (obj->type == CYLINDER
		&& hit_cylinder(ray, (t_cylinder *)obj->data, &t)
		&& is_valid_t(t, hit->t))
		update_hit(hit, t, obj, CYLINDER);
}

bool	hit_objects(t_scene *scene, t_ray ray, t_hit *hit)
{
	int	i;

	hit->t = INFINITY;
	hit->object = NULL;
	hit->type = INVALID;
	i = 0;
	while (i < scene->object_count)
	{
		test_object(scene->objects[i], ray, hit);
		i++;
	}
	return (hit->object != NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_plane.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/08 15:42:52 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 15:09:54 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

bool	hit_plane(t_ray ray, t_plane *pl, double *t)
{
	double	denom;
	t_vec3	p0l0;
	double	temp_t;

	denom = vec3_dot(pl->normal, ray.direction);
	if (fabs(denom) < 1e-6)
		return (false);
	p0l0 = vec3_sub(pl->point, ray.origin);
	temp_t = vec3_dot(p0l0, pl->normal) / denom;
	if (temp_t < 1e-6)
		return (false);
	*t = temp_t;
	return (true);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_sphere.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/08 15:36:51 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/15 17:33:27 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

/*
typedef struct s_sphere_hit
{
	t_vec3	oc;
	double	a;
	double	b;
	double	c;
	double	delta;
	double	sqrt_d;
	double	t0;
	double	t1;
}	t_sphere_hit;
*/

bool	hit_sphere(t_ray ray, t_sphere *sp, double *t)
{
	t_sphere_hit	h;

	h.oc = vec3_sub(ray.origin, sp->center);
	h.a = vec3_dot(ray.direction, ray.direction);
	h.b = 2.0 * vec3_dot(h.oc, ray.direction);
	h.c = vec3_dot(h.oc, h.oc)
		- (sp->diameter / 2) * (sp->diameter / 2);
	h.delta = h.b * h.b - 4 * h.a * h.c;
	if (h.delta < 0)
		return (false);
	h.sqrt_d = sqrt(h.delta);
	h.t0 = (-h.b - h.sqrt_d) / (2 * h.a);
	h.t1 = (-h.b + h.sqrt_d) / (2 * h.a);
	if (h.t0 > 1e-6)
	{
		*t = h.t0;
		return (true);
	}
	if (h.t1 > 1e-6)
	{
		*t = h.t1;
		return (true);
	}
	return (false);
}
