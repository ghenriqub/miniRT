/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   0-main.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:44:29 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/02 16:42:39 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

/*
static void ft_print_vec3(t_vec3 v)
{
    printf("(%.3f, %.3f, %.3f)", v.x, v.y, v.z);
}

static void ft_print_rgb(t_rgb c)
{
    printf("(%d, %d, %d)", c.r, c.g, c.b);
}

static const char *ft_obj_name(t_obj_type t)
{
    if (t == SPHERE) return "SPHERE";
    if (t == PLANE) return "PLANE";
    if (t == CYLINDER) return "CYLINDER";
    return "UNKNOWN";
}

static void ft_print_object_data(t_object *obj)
{
    if (!obj || !obj->data)
        return;

    if (obj->type == SPHERE)
    {
        t_sphere *s = (t_sphere *)obj->data;
        printf("      center = ");
        ft_print_vec3(s->center);
        printf("\n      diameter = %.3f\n", s->diameter);
    }
    else if (obj->type == PLANE)
    {
        t_plane *p = (t_plane *)obj->data;
        printf("      point  = ");
        ft_print_vec3(p->point);
        printf("\n      normal = ");
        ft_print_vec3(p->normal);
        printf("\n");
    }
    else if (obj->type == CYLINDER)
    {
        t_cylinder *c = (t_cylinder *)obj->data;
        printf("      center = ");
        ft_print_vec3(c->center);
        printf("\n      normal = ");
        ft_print_vec3(c->normal);
        printf("\n      diameter = %.3f\n", c->diameter);
        printf("      height = %.3f\n", c->height);
    }
}

static void ft_print_camdata(t_camdata c)
{
    printf("  camdata:\n");
    printf("    forward  = ");
    ft_print_vec3(c.forward);
    printf("\n    right    = ");
    ft_print_vec3(c.right);
    printf("\n    up       = ");
    ft_print_vec3(c.up);
    printf("\n    viewport = %.3f x %.3f\n", c.viewport_width, c.viewport_height);
}


void ft_print_scene(t_scene *scene)
{
    if (!scene)
        return;

    printf("\n=========== SCENE ===========\n");

    // AMBIENT LIGHT 
    if (scene->ambient)
    {
        printf("\nAmbient Light:\n");
        printf("  ratio = %.3f\n", scene->ambient->ratio);
        printf("  color = ");
        ft_print_rgb(scene->ambient->color);
        printf("\n");
    }

    // CAMERA 
    if (scene->camera)
    {
        printf("\nCamera:\n");
        printf("  position = ");
        ft_print_vec3(scene->camera->position);
        printf("\n  vector   = ");
        ft_print_vec3(scene->camera->vector);
        printf("\n  fov      = %d\n", scene->camera->fov);
        ft_print_camdata(scene->camera->camdata);
    }

    // LIGHTS 
    printf("\nLights (%d):\n", scene->light_count);
    for (int i = 0; i < scene->light_count; i++)
    {
        printf("  Light %d:\n", i);
        printf("    position = ");
        ft_print_vec3(scene->lights[i]->position);
        printf("\n    ratio = %.3f\n", scene->lights[i]->ratio);
        printf("    color = ");
        ft_print_rgb(scene->lights[i]->color);
        printf("\n");
    }

    // OBJECTS 
    printf("\nObjects (%d):\n", scene->object_count);
    for (int i = 0; i < scene->object_count; i++)
    {
        printf("  Object %d:\n", i);
        printf("    type = %s\n", ft_obj_name(scene->objects[i]->type));
        ft_print_object_data(scene->objects[i]);
    }

    printf("\n==============================\n\n");
}*/

int	main(int argc, char **argv)
{
	t_scene	*scene;

	if (argc != 2 || ft_is_rt(argv[1]))
		ft_exit(ERROR_PARAM, 1);
	scene = ft_get_scene(argv[1]);
	// ft_init_viewport(scene); aqui precisa inicializar a parte de left up right randerer ray.c
	//ft_init_graphics(scene);
	//ft_print_scene(scene);
	ft_free_scene(scene);
	return (0);
}

void	ft_exit(char *message, int code)
{
	if (message)
		ft_putendl_fd(message, 2);
	exit(code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   1-get_args.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 16:20:41 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/18 15:39:00 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// 1 - fill Args struct with user input
// 2 - Arguments Parser, if all is ok, return struct scene
t_scene	*ft_get_scene(char *file)
{
	t_args	*args;
	t_scene	*scene;

	args = ft_allocate_args(file);
	scene = ft_parser(args);
	ft_free_args(args);
	return (scene);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   2-allocate.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/15 12:08:27 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 20:49:06 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

static int	ft_is_object(char *line)
{
	int	i;

	i = 0;
	if (!line)
		return (0);
	while (line[i] == ' ')
		i++;
	if (!ft_strncmp(&line[i], "sp ", 3))
		return (1);
	if (!ft_strncmp(&line[i], "pl ", 3))
		return (1);
	if (!ft_strncmp(&line[i], "cy ", 3))
		return (1);
	return (0);
}

static int	*ft_count(char *file)
{
	int		*count;
	int		fd;
	char	*line;
	int		i;

	count = ft_calloc(2, sizeof(int));
	if (!count)
		ft_exit(ERROR_MALLOC, 2);
	fd = ft_get_fd(file);
	line = ft_strtrim(get_next_line(fd), " \t\r\b\n");
	while (line)
	{
		i = 0;
		ft_tab_to_space(line);
		while (line[i] == ' ')
			i++;
		if (!ft_strncmp(&line[i], "L ", 2))
			count[0]++;
		else if (ft_is_object(line))
			count[1]++;
		free(line);
		line = ft_strtrim(get_next_line(fd), " \t\r\b\n");
	}
	close(fd);
	return (count);
}

static char	*ft_is_double(t_args *args, char *target, char *line, int fd)
{
	if (target)
	{
		free(line);
		ft_free_args(args);
		close(fd);
		ft_exit(ERROR_SCENE, 2);
	}
	return (ft_strdup(line));
}

// 1 - set args NULL
// 2 - strtrim for erase spaces
// 3 - fill scruct according the type of the lines
// 4 - Cam and ambient light can't duplicate
// if invalid argument, call ft_is_double for free and exit
void	ft_put_argument(t_args *args, int fd)
{
	int		i;
	int		k;
	char	*line;

	args->ambient_light = NULL;
	i = 0;
	k = 0;
	line = ft_strtrim(get_next_line(fd), " \t\r\b\n");
	while (line)
	{
		ft_tab_to_space(line);
		if (!ft_strncmp(line, "A ", 2))
			args->ambient_light = ft_is_double(args,
					args->ambient_light, line, fd);
		else if (!ft_strncmp(line, "C ", 2))
			args->camera = ft_is_double(args, args->camera, line, fd);
		else if (!ft_strncmp(line, "L ", 2))
			args->light[k++] = ft_strdup(line);
		else if (ft_is_object(line))
			args->objects[i++] = ft_strdup(line);
		else if (line[0] != '\n' && line[0] != '#')
			ft_is_double(args, "invalid", line, fd);
		free(line);
		line = ft_strtrim(get_next_line(fd), " \t\r\b\n");
	}
}

// 1- call ft_count to get number of the Lights and objets
// 2 - allocate memory for struct and arrays-arrays
// 3 - call ft_put_argument to fill struct
t_args	*ft_allocate_args(char *file)
{
	t_args	*args;
	int		*count;
	int		fd;

	count = ft_count(file);
	args = ft_calloc(sizeof(t_args), 1);
	args->camera = NULL;
	args->light_count = count[0];
	args->obj_count = count[1];
	free(count);
	args->objects = ft_calloc(sizeof(char *), (args->obj_count + 1));
	if (!args->objects)
		ft_exit(ERROR_MALLOC, 2);
	args->objects[args->obj_count] = NULL;
	if (args->light_count > 0)
	{
		args->light = ft_calloc(sizeof(char *), (args->light_count + 1));
		if (!args->light_count)
			ft_exit(ERROR_MALLOC, 2);
		args->objects[args->light_count] = NULL;
	}
	fd = ft_get_fd(file);
	ft_put_argument(args, fd);
	close(fd);
	return (args);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.1-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/19 16:20:22 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/02 15:37:26 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// verified if all str value is a number
int	ft_is_number(char *str)
{
	int	i;

	i = 0;
	if (!str || !*str)
		return (0);
	while (str[i])
	{
		if (str[i] < '0' || str[i] > '9')
			return (0);
		i++;
	}
	return (1);
}

// 1 - verified if have 3 parts when we split with ","
// 2 - check if each part is a number and if it are between 0 - 255. 
int	ft_parser_rgb(char *str)
{
	char	**s;
	int		i;
	int		value;

	s = ft_split(str, ',');
	if (!s || count_parts(str, ',') != 3)
		return (ft_free_split(s), 0);
	i = -1;
	while (++i < 3)
	{
		if (!ft_is_number(s[i]))
			return (ft_free_split(s), 0);
		value = ft_atoi(s[i]);
		if (value < 0 || value > 255)
			return (ft_free_split(s), 0);
	}
	ft_free_split(s);
	return (1);
}

// 1- call float format for check if the argument is a float
// 2 - check if value are between min and max
int	ft_parser_ratio(char *str, double min, double max)
{
	float	value;

	if (!ft_float_format(str))
		return (0);
	value = ft_atod(str);
	if (value < min || value > max)
		return (0);
	return (1);
}

// 1 - verify if have 3 parts when we split with ",".
// 2 - check if all parts are in float format.
int	ft_parser_vec3(char *str)
{
	char	**p;

	p = ft_split(str, ',');
	if (!p || count_parts(str, ',') != 3)
		return (ft_free_split(p), 0);
	if (!ft_float_format(p[0])
		|| !ft_float_format(p[1])
		|| !ft_float_format(p[2]))
		return (ft_free_split(p), 0);
	ft_free_split(p);
	return (1);
}

// 1 - call parser vec3 for verify if str is a vector with 3 argument
// 2 - call parser ratio, check if is a float and between -1 and 1.
int	ft_is_normalized(char *str)
{
	char	**args;

	if (!ft_parser_vec3(str))
		return (0);
	args = ft_split(str, ',');
	if (!ft_parser_ratio(args[0], -1, 1)
		|| !ft_parser_ratio(args[1], -1, 1)
		|| !ft_parser_ratio(args[2], -1, 1))
	{
		ft_free_split(args);
		return (0);
	}
	ft_free_split(args);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.2-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 14:13:09 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/02 15:35:41 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// verify if is a float and if are between 0 - 180.
int	ft_parse_fov(char *str)
{
	float	fov;

	if (!ft_float_format(str))
		return (0);
	fov = ft_atod(str);
	if (fov < 0 || fov > 180)
		return (0);
	return (1);
}

// verify if is a digit and if have 0 or 1 point
static int	ft_float_format_util(const char *str)
{
	int	i;
	int	digits;
	int	dots;

	i = 0;
	digits = 0;
	dots = 0;
	while (str[i])
	{
		if (str[i] >= '0' && str[i] <= '9')
			digits++;
		else if (str[i] == '.')
		{
			if (++dots > 1 || !str[i + 1])
				return (0);
		}
		else
			return (0);
		i++;
	}
	return (digits > 0);
}

// verify if have a signal, and call util
int	ft_float_format(const char *str)
{
	int	i;

	if (!str || !*str)
		return (0);
	i = 0;
	if (str[i] == '+' || str[i] == '-')
		i++;
	if (!str[i])
		return (0);
	return (ft_float_format_util(&str[i]));
}

// used for free scructs
void	**ft_alloc_arraystruc(int count, size_t type_size)
{
	void	**arr;
	int		i;

	if (count <= 0)
		return (NULL);
	arr = ft_calloc(count + 1, sizeof(void *));
	if (!arr)
		return (NULL);
	i = 0;
	while (i < count)
	{
		arr[i] = ft_calloc(1, type_size);
		if (!arr[i])
		{
			while (--i >= 0)
				free(arr[i]);
			free(arr);
			return (NULL);
		}
		i++;
	}
	arr[count] = NULL;
	return (arr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.3-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/19 17:02:49 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/02 15:34:36 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// split str and return struct RGB.
t_rgb	ft_get_rgb(char *str)
{
	t_rgb	rgb;
	char	**vals;

	vals = ft_split(str, ',');
	rgb.r = ft_atoi(vals[0]);
	rgb.g = ft_atoi(vals[1]);
	rgb.b = ft_atoi(vals[2]);
	ft_free_split(vals);
	return (rgb);
}

// return a vector with 3 values.
t_vec3	ft_get_vec3(char *str)
{
	t_vec3	v;
	char	**parts;

	parts = ft_split(str, ',');
	v.x = ft_atod(parts[0]);
	v.y = ft_atod(parts[1]);
	v.z = ft_atod(parts[2]);
	ft_free_split(parts);
	return (v);
}

// translate \t to ' '
char	*ft_tab_to_space(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (str[i] == '\t')
			str[i] = ' ';
		i++;
	}
	return (str);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.4-parser_obj_utils.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 16:55:35 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/02 15:35:46 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

void	*ft_parser_sphere(char *line)
{
	t_sphere	*sp;
	char		**args;

	if (count_parts(line, ' ') != 4)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "sp", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_float_format(args[2])
		|| !ft_parser_rgb(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	sp = ft_calloc(1, sizeof(t_sphere));
	sp->center = ft_get_vec3(args[1]);
	sp->diameter = ft_atod(args[2]);
	sp->color = ft_get_rgb(args[3]);
	ft_free_split(args);
	return (sp);
}

void	*ft_parser_plane(char *line)
{
	t_plane	*pl;
	char	**args;

	if (count_parts(line, ' ') != 4)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "pl", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_parser_rgb(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	pl = ft_calloc(1, sizeof(t_plane));
	pl->point = ft_get_vec3(args[1]);
	pl->normal = ft_get_vec3(args[2]);
	pl->color = ft_get_rgb(args[3]);
	ft_free_split(args);
	return (pl);
}

void	*ft_parser_cylinder(char *line)
{
	t_cylinder	*cy;
	char		**args;

	if (count_parts(line, ' ') != 6)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "cy", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_float_format(args[3])
		|| !ft_float_format(args[4])
		|| !ft_parser_rgb(args[5]))
		return (ft_free_split(args), NULL);
	cy = ft_calloc(1, sizeof(t_cylinder));
	cy->center = ft_get_vec3(args[1]);
	cy->normal = ft_get_vec3(args[2]);
	cy->diameter = ft_atod(args[3]);
	cy->height = ft_atod(args[4]);
	cy->color = ft_get_rgb(args[5]);
	ft_free_split(args);
	return (cy);
}

// return struct according to type.
void	*ft_get_obj(t_obj_type type, char *line)
{
	if (type == SPHERE)
		return (ft_parser_sphere(line));
	if (type == PLANE)
		return (ft_parser_plane(line));
	if (type == CYLINDER)
		return (ft_parser_cylinder(line));
	return (NULL);
}

// define the type of the object
t_obj_type	ft_get_type(char *line)
{
	if (!ft_strncmp(line, "sp ", 3))
		return (SPHERE);
	if (!ft_strncmp(line, "pl ", 3))
		return (PLANE);
	if (!ft_strncmp(line, "cy ", 3))
		return (CYLINDER);
	return (INVALID);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3-parser.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/15 12:38:39 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/02 15:35:39 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_scene	*ft_parser(t_args *args)
{
	t_scene	*scene;

	scene = ft_calloc(sizeof(t_scene), 1);
	scene->light_count = args->light_count;
	scene->object_count = args->obj_count;
	scene->ambient = ft_parser_al(args->ambient_light);
	scene->camera = ft_parser_c(args->camera);
	scene->lights = ft_parser_l(args->light, scene->light_count);
	scene->objects = ft_parser_ob(args->objects, scene->object_count);
	if (scene->ambient == NULL || scene->camera == NULL
		|| (scene->light_count > 0 && scene->lights == NULL)
		|| (scene->objects == NULL))
	{
		ft_free_args(args);
		ft_free_scene(scene);
		ft_exit(ERROR_SCENE, 2);
	}
	scene->camera->camdata = ft_compute_camera(*scene->camera, WIDTH, HEIGHT);
	return (scene);
}

// 1 - count parts to verified if have 3 arguments.
// 2 - if with 3 condictions:
//		first argument is 'A'.
//			parser ratio, if arguments is a float 0.0 - 1.0.
//				parser RGB xxx,xxx,xxx.
// 3 - strdup and get rgb for allocate arguments.
t_ambient_light	*ft_parser_al(char *input)
{
	t_ambient_light	*al;
	char			**args;

	if (count_parts(input, ' ') != 3)
		return (NULL);
	args = ft_split(input, ' ');
	if (ft_strncmp(args[0], "A", ft_strlen(args[0])) != 0
		|| !ft_parser_ratio(args[1], 0.0, 1.0)
		|| !ft_parser_rgb(args[2]))
	{
		ft_free_split(args);
		return (NULL);
	}
	al = ft_calloc(sizeof(t_ambient_light), 1);
	al->ratio = ft_atod(args[1]);
	al->color = ft_get_rgb(args[2]);
	ft_free_split(args);
	return (al);
}

t_camera	*ft_parser_c(char *input)
{
	t_camera	*camera;
	char		**args;

	if (count_parts(input, ' ') != 4)
		return (NULL);
	args = ft_split(input, ' ');
	if (ft_strncmp(args[0], "C", ft_strlen(args[0])) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_parse_fov(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	camera = ft_calloc(sizeof(t_camera), 1);
	camera->position = ft_get_vec3(args[1]);
	camera->vector = ft_get_vec3(args[2]);
	camera->fov = ft_atod(args[3]);
	ft_free_split(args);
	return (camera);
}

t_light	**ft_parser_l(char **input, int count_light)
{
	t_light	**light;
	char	**args;
	int		i;

	light = (t_light **)ft_alloc_arraystruc(count_light, sizeof(t_light));
	if (!light)
		return (NULL);
	i = -1;
	while (input[++i])
	{
		if (count_parts(input[i], ' ') != 4)
			return (ft_free_arraystruc((void **)light, count_light), NULL);
		args = ft_split(input[i], ' ');
		if (ft_strncmp(args[0], "L", ft_strlen(args[0])) != 0
			|| !ft_parser_vec3(args[1])
			|| !ft_parser_ratio(args[2], 0, 1)
			|| !ft_parser_rgb(args[3]))
			return (ft_free_arraystruc((void **)light, count_light),
				ft_free_split(args), NULL);
		light[i]->position = ft_get_vec3(args[1]);
		light[i]->ratio = ft_atod(args[2]);
		light[i]->color = ft_get_rgb(args[3]);
		ft_free_split(args);
	}
	return (light);
}

t_object	**ft_parser_ob(char **input, int count_objects)
{
	t_object	**objects;
	int			i;

	objects = (t_object **)ft_alloc_arraystruc(count_objects, sizeof(t_object));
	if (!objects)
		return (NULL);
	i = -1;
	while (++i < count_objects)
	{
		objects[i]->type = ft_get_type(input[i]);
		if (objects[i]->type == INVALID)
			return (ft_free_objects_struc(objects, count_objects), NULL);
		objects[i]->data = ft_get_obj(objects[i]->type, input[i]);
		if (objects[i]->data == NULL)
			return (ft_free_objects_struc(objects, count_objects), NULL);
	}
	return (objects);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_functions1.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 16:13:14 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 22:07:26 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"
/*this file have free functions.*/

void	ft_free_arraystruc(void **arr, int count)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (i < count)
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

void	ft_free_scene(t_scene *scene)
{
	int	i;

	if (!scene)
		return ;
	free(scene->ambient);
	free(scene->camera);
	if (scene->lights)
	{
		i = -1;
		while (scene->lights[++i])
			free(scene->lights[i]);
		free(scene->lights);
	}
	if (scene->objects)
		ft_free_objects_struc(scene->objects, scene->object_count);
	free(scene);
}

void	ft_free_objectt(t_object *obj)
{
	if (!obj)
		return ;
	if (obj->data)
	{
		if (obj->type == SPHERE)
			free((t_sphere *)obj->data);
		else if (obj->type == PLANE)
			free((t_plane *)obj->data);
		else if (obj->type == CYLINDER)
			free((t_cylinder *)obj->data);
	}
	free(obj);
}

void	ft_free_objects_struc(t_object **arr, int count)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (i < count)
	{
		ft_free_objectt(arr[i]);
		i++;
	}
	free(arr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_functions.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:46:12 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/21 22:06:47 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// this function verified if argument is .rt
int	ft_is_rt(char *file)
{
	size_t	len;

	len = ft_strlen(file);
	if (ft_strncmp(&file[len - 3], ".rt", 3))
		return (1);
	return (0);
}

int	ft_get_fd(char *file)
{
	int	fd;

	fd = open(file, O_RDONLY);
	if (fd < 0)
		ft_exit(ERROR_FILE, 2);
	return (fd);
}

void	ft_free_split(char **arr)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

void	ft_free_args(t_args *args)
{
	if (args->ambient_light)
		free(args->ambient_light);
	if (args->camera)
		free(args->camera);
	if (args->light)
		ft_free_split(args->light);
	if (args->objects)
		ft_free_split(args->objects);
	free(args);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cam_data.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/02 16:42:02 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/03 15:50:17 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_camdata	ft_compute_camera(t_camera cam, int width, int height)
{
	t_camdata	c;
	t_vec3		world_up;
	double		fov_rad;

	world_up = ft_get_vec3("0,1,0");
	c.forward = vec3_normalize(cam.vector);
	c.right = vec3_normalize(vec3_cross(c.forward, world_up));
	c.up = vec3_cross(c.right, c.forward);
	fov_rad = cam.fov * M_PI / 180.0;
	c.viewport_height = 2 * tan(fov_rad / 2);
	c.viewport_width = c.viewport_height * ((double)width / height);
	return (c);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ray.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/03 15:41:55 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/03 15:54:05 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_ray	ft_ray(t_vec3 o, t_vec3 d)
{
	t_ray	r;

	r.origin = o;
	r.direction = vec3_normalize(d);
	return (r);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minilibx_setup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/01 19:33:59 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:24:04 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

void	ft_init_graphics(t_scene *scene)
{
	scene->disp.mlx = mlx_init();
	if (!scene->disp.mlx)
		return (1);
	scene->disp.win = mlx_new_window(scene->disp.mlx, WIDTH, HEIGHT, "minirt");
	if (!scene->disp.win)
		return (1);
	scene->disp.img = mlx_new_image(scene->disp.mlx, WIDTH, HEIGHT);
	if (!scene->disp.img)
		return (1);
	scene->disp.addr = mlw_get_data_addr(scene->disp.img, &scene->disp.bpp,
			&scene->disp.line_length, &scene->disp.endian);
	if (!scene->disp.addr)
		return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minirt.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:42:30 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/03 16:24:56 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINIRT_H
# define MINIRT_H

# include "libft.h"
# include <stdbool.h>
# include <math.h>

# define M_PI	3.14159265358979323846
# define ERROR_PARAM "Error\nUsage: ./minirt <file.rt>"
# define ERROR_FILE "Error\nCannot open this found."
# define ERROR_MALLOC "Error\nCannot allocate memmory."
# define ERROR_SCENE "Error\ninvalid scene."
# define WIDTH 800
# define HEIGHT 1400

typedef struct s_vec3
{
	double	x;
	double	y;
	double	z;
}	t_vec3;

typedef struct s_camdata
{
	t_vec3	forward;
	t_vec3	right;
	t_vec3	up;

	float	viewport_width;
	float	viewport_height;
}	t_camdata;

typedef struct s_args
{
	char	*ambient_light;
	char	*camera;
	char	**light;
	int		light_count;
	char	**objects;
	int		obj_count;
}	t_args;

typedef struct s_rgb
{
	int	r;
	int	g;
	int	b;
}	t_rgb;

typedef struct s_ambient_light
{
	double	ratio;
	t_rgb	color;
}	t_ambient_light;

typedef struct s_camera
{
	t_vec3		position;
	t_vec3		vector;
	t_camdata	camdata;
	int			fov;
}	t_camera;

typedef struct s_light
{
	t_vec3	position;
	double	ratio;
	t_rgb	color;
}	t_light;

typedef struct s_sphere
{
	t_vec3	center;
	double	diameter;
	t_rgb	color;
}	t_sphere;

typedef struct s_plane
{
	t_vec3	point;
	t_vec3	normal;
	t_rgb	color;
}	t_plane;

typedef struct s_cylinder
{
	t_vec3	center;
	t_vec3	normal;
	double	diameter;
	double	height;
	t_rgb	color;
}	t_cylinder;

typedef enum e_obj_type
{
	SPHERE,
	PLANE,
	CYLINDER,
	INVALID
}	t_obj_type;

typedef struct s_object
{
	t_obj_type	type;
	void		*data;
}	t_object;

typedef struct s_graphics
{
	void	*mlx;
	void	*win;
	void	*img;
	char	*addr;
	int		height;
	int		width;
	int		bpp;
	int		line_length;
	int		endian;
}	t_graphics;

typedef struct s_scene
{
	t_ambient_light	*ambient;
	t_camera		*camera;
	t_light			**lights;
	int				light_count;
	t_object		**objects;
	int				object_count;
	t_graphics		disp;

}	t_scene;

typedef struct s_ray
{
	t_vec3	origin;
	t_vec3	direction;
}	t_ray;

// ============ Parser ============

void			ft_exit(char *message, int code);
int				ft_is_rt(char *file);
t_scene			*ft_get_scene(char *file);
int				ft_get_fd(char *file);
void			ft_put_argument(t_args *args, int fd);
void			ft_free_args(t_args *args);
t_scene			*ft_parser(t_args *args);
t_args			*ft_allocate_args(char *file);
t_ambient_light	*ft_parser_al(char *input);
t_camera		*ft_parser_c(char *input);
t_light			**ft_parser_l(char **input, int count_light);
t_object		**ft_parser_ob(char **input, int count_objects);
t_rgb			ft_get_rgb(char *str);
int				ft_parser_rgb(char *str);
t_camera		*ft_parser_c(char *input);
int				ft_parser_ratio(char *str, double min, double max);
int				ft_is_normalized(char *str);
int				ft_is_number(char *str);
int				ft_parser_vec3(char *str);
t_vec3			ft_get_vec3(char *str);
int				ft_float_format(const char *str);
int				ft_parse_fov(char *str);
void			**ft_alloc_arraystruc(int count, size_t type_size);
void			ft_free_arraystruc(void **arr, int count);
void			ft_free_scene(t_scene *scene);
void			ft_free_split(char **arr);
void			*ft_get_obj(t_obj_type type, char *line);
t_obj_type		ft_get_type(char *line);
char			*ft_tab_to_space(char *str);
void			ft_free_objects_struc(t_object **arr, int count);

// ============ Vectors ============
t_vec3			vec3_add(t_vec3 vec1, t_vec3 vec2);
t_vec3			atovec3(char **vec);
bool			vec3_cmp(t_vec3 vec1, t_vec3 vec2);
double			vec3_cos(t_vec3 vec1, t_vec3 vec2);
t_vec3			vec3_cross(t_vec3 vec1, t_vec3 vec2);
double			vec3_dot(t_vec3 vec1, t_vec3 vec2);
double			vec3_len(t_vec3 vec);
t_vec3			vec3_new(double x, double y, double z);
t_vec3			vec3_normalize(t_vec3 vec);
t_vec3			vec3_scale(t_vec3 vec1, double scalar);
t_vec3			vec3_sub(t_vec3 vec1, t_vec3 vec2);

// ============ ray ============
t_camdata		ft_compute_camera(t_camera cam, int width, int height);
t_ray			ft_ray(t_vec3 o, t_vec3 d);

#endif
