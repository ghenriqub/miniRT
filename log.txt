
===== srcs/parser/1-get_scene.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   1-get_args.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 16:20:41 by lgertrud          #+#    #+#             */
/*   Updated: 2025/11/18 15:39:00 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// 1 - fill Args struct with user input
// 2 - Arguments Parser, if all is ok, return struct scene
t_scene	*ft_get_scene(char *file)
{
	t_args	*args;
	t_scene	*scene;

	args = ft_allocate_args(file);
	scene = ft_parser(args);
	ft_free_args(args);
	return (scene);
}

===== srcs/parser/3.3-parser_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.3-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/19 17:02:49 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/02 15:34:36 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// split str and return struct RGB.
t_rgb	ft_get_rgb(char *str)
{
	t_rgb	rgb;
	char	**vals;

	vals = ft_split(str, ',');
	rgb.r = ft_atoi(vals[0]);
	rgb.g = ft_atoi(vals[1]);
	rgb.b = ft_atoi(vals[2]);
	ft_free_split(vals);
	return (rgb);
}

// return a vector with 3 values.
t_vec3	ft_get_vec3(char *str)
{
	t_vec3	v;
	char	**parts;

	parts = ft_split(str, ',');
	v.x = ft_atod(parts[0]);
	v.y = ft_atod(parts[1]);
	v.z = ft_atod(parts[2]);
	ft_free_split(parts);
	return (v);
}

// translate \t to ' '
char	*ft_tab_to_space(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		if (str[i] == '\t')
			str[i] = ' ';
		i++;
	}
	return (str);
}

===== srcs/parser/3.4-parser_obj_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.4-parser_obj_utils.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 16:55:35 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/02 15:35:46 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

void	*ft_parser_sphere(char *line)
{
	t_sphere	*sp;
	char		**args;

	if (count_parts(line, ' ') != 4)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "sp", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_float_format(args[2])
		|| !ft_parser_rgb(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	sp = ft_calloc(1, sizeof(t_sphere));
	sp->center = ft_get_vec3(args[1]);
	sp->diameter = ft_atod(args[2]);
	sp->color = ft_get_rgb(args[3]);
	ft_free_split(args);
	return (sp);
}

void	*ft_parser_plane(char *line)
{
	t_plane	*pl;
	char	**args;

	if (count_parts(line, ' ') != 4)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "pl", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_parser_rgb(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	pl = ft_calloc(1, sizeof(t_plane));
	pl->point = ft_get_vec3(args[1]);
	pl->normal = ft_get_vec3(args[2]);
	pl->color = ft_get_rgb(args[3]);
	ft_free_split(args);
	return (pl);
}

void	*ft_parser_cylinder(char *line)
{
	t_cylinder	*cy;
	char		**args;

	if (count_parts(line, ' ') != 6)
		return (NULL);
	args = ft_split(line, ' ');
	if (!args)
		return (NULL);
	if (ft_strncmp(args[0], "cy", 3) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_float_format(args[3])
		|| !ft_float_format(args[4])
		|| !ft_parser_rgb(args[5]))
		return (ft_free_split(args), NULL);
	cy = ft_calloc(1, sizeof(t_cylinder));
	cy->center = ft_get_vec3(args[1]);
	cy->normal = ft_get_vec3(args[2]);
	cy->diameter = ft_atod(args[3]);
	cy->height = ft_atod(args[4]);
	cy->color = ft_get_rgb(args[5]);
	ft_free_split(args);
	return (cy);
}

// return struct according to type.
void	*ft_get_obj(t_obj_type type, char *line)
{
	if (type == SPHERE)
		return (ft_parser_sphere(line));
	if (type == PLANE)
		return (ft_parser_plane(line));
	if (type == CYLINDER)
		return (ft_parser_cylinder(line));
	return (NULL);
}

// define the type of the object
t_obj_type	ft_get_type(char *line)
{
	if (!ft_strncmp(line, "sp ", 3))
		return (SPHERE);
	if (!ft_strncmp(line, "pl ", 3))
		return (PLANE);
	if (!ft_strncmp(line, "cy ", 3))
		return (CYLINDER);
	return (INVALID);
}

===== srcs/parser/3.2-parser_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.2-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 14:13:09 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/10 11:59:59 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// verify if is a float and if are between 0 - 180.
int	ft_parse_fov(char *str)
{
	float	fov;

	if (!ft_float_format(str))
		return (0);
	fov = ft_atod(str);
	if (fov < 0 || fov > 180)
		return (0);
	return (1);
}

// verify if is a digit and if have 0 or 1 point
static int	ft_float_format_util(const char *str)
{
	int	i;
	int	digits;
	int	dots;

	i = 0;
	digits = 0;
	dots = 0;
	while (str[i])
	{
		if (str[i] >= '0' && str[i] <= '9')
			digits++;
		else if (str[i] == '.')
		{
			if (++dots > 1 || !str[i + 1])
				return (0);
		}
		else
			return (0);
		i++;
	}
	return (digits > 0);
}

// verify if have a signal, and call util
int	ft_float_format(const char *str)
{
	int	i;

	if (!str || !*str)
		return (0);
	i = 0;
	if (str[i] == '+' || str[i] == '-')
		i++;
	if (!str[i])
		return (0);
	return (ft_float_format_util(&str[i]));
}

// used for free scructs
void	**ft_alloc_arraystruc(int count, size_t type_size)
{
	void	**arr;
	int		i;

	if (count <= 0)
		return (NULL);
	arr = ft_calloc(count + 1, sizeof(void *));
	if (!arr)
		return (NULL);
	i = 0;
	while (i < count)
	{
		arr[i] = ft_calloc(1, type_size);
		if (!arr[i])
		{
			while (--i >= 0)
				free(arr[i]);
			free(arr);
			return (NULL);
		}
		i++;
	}
	arr[count] = NULL;
	return (arr);
}

===== srcs/parser/0-main.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   0-main.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:44:29 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 21:16:49 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

/*
static void ft_print_vec3(t_vec3 v)
{
    printf("(%.3f, %.3f, %.3f)", v.x, v.y, v.z);
}

static void ft_print_rgb(t_rgb c)
{
    printf("(%d, %d, %d)", c.r, c.g, c.b);
}

static const char *ft_obj_name(t_obj_type t)
{
    if (t == SPHERE) return "SPHERE";
    if (t == PLANE) return "PLANE";
    if (t == CYLINDER) return "CYLINDER";
    return "UNKNOWN";
}

static void ft_print_object_data(t_object *obj)
{
    if (!obj || !obj->data)
        return;

    if (obj->type == SPHERE)
    {
        t_sphere *s = (t_sphere *)obj->data;
        printf("      center = ");
        ft_print_vec3(s->center);
        printf("\n      diameter = %.3f\n", s->diameter);
    }
    else if (obj->type == PLANE)
    {
        t_plane *p = (t_plane *)obj->data;
        printf("      point  = ");
        ft_print_vec3(p->point);
        printf("\n      normal = ");
        ft_print_vec3(p->normal);
        printf("\n");
    }
    else if (obj->type == CYLINDER)
    {
        t_cylinder *c = (t_cylinder *)obj->data;
        printf("      center = ");
        ft_print_vec3(c->center);
        printf("\n      normal = ");
        ft_print_vec3(c->normal);
        printf("\n      diameter = %.3f\n", c->diameter);
        printf("      height = %.3f\n", c->height);
    }
}

static void ft_print_camdata(t_camdata c)
{
    printf("  camdata:\n");
    printf("    forward  = ");
    ft_print_vec3(c.forward);
    printf("\n    right    = ");
    ft_print_vec3(c.right);
    printf("\n    up       = ");
    ft_print_vec3(c.up);
    printf("\n    viewport = %.3f x %.3f\n", c.viewport_width, c.viewport_height);
}


void ft_print_scene(t_scene *scene)
{
    if (!scene)
        return;

    printf("\n=========== SCENE ===========\n");

    // AMBIENT LIGHT 
    if (scene->ambient)
    {
        printf("\nAmbient Light:\n");
        printf("  ratio = %.3f\n", scene->ambient->ratio);
        printf("  color = ");
        ft_print_rgb(scene->ambient->color);
        printf("\n");
    }

    // CAMERA 
    if (scene->camera)
    {
        printf("\nCamera:\n");
        printf("  position = ");
        ft_print_vec3(scene->camera->position);
        printf("\n  vector   = ");
        ft_print_vec3(scene->camera->vector);
        printf("\n  fov      = %d\n", scene->camera->fov);
        ft_print_camdata(scene->camera->camdata);
    }

    // LIGHTS 
    printf("\nLights (%d):\n", scene->light_count);
    for (int i = 0; i < scene->light_count; i++)
    {
        printf("  Light %d:\n", i);
        printf("    position = ");
        ft_print_vec3(scene->lights[i]->position);
        printf("\n    ratio = %.3f\n", scene->lights[i]->ratio);
        printf("    color = ");
        ft_print_rgb(scene->lights[i]->color);
        printf("\n");
    }

    // OBJECTS 
    printf("\nObjects (%d):\n", scene->object_count);
    for (int i = 0; i < scene->object_count; i++)
    {
        printf("  Object %d:\n", i);
        printf("    type = %s\n", ft_obj_name(scene->objects[i]->type));
        ft_print_object_data(scene->objects[i]);
    }

    printf("\n==============================\n\n");
}*/

int	main(int argc, char **argv)
{
	t_scene	*scene;

	if (argc != 2 || ft_is_rt(argv[1]))
		ft_exit(ERROR_PARAM, 1);
	scene = ft_get_scene(argv[1]);
	// ft_init_viewport(scene); aqui precisa inicializar a parte de left up right randerer ray.c
	ft_init_graphics(scene);
	render_scene(scene);
	mlx_key_hook(scene->disp.win, key_press, scene);
	mlx_hook(scene->disp.win, 17, 0, close_window, scene);
	mlx_loop(scene->disp.mlx);
	// ft_free_scene(scene);
	return (0);
}

void	ft_exit(char *message, int code)
{
	if (message)
		ft_putendl_fd(message, 2);
	exit(code);
}

===== srcs/parser/2-allocate.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   2-allocate.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/15 12:08:27 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/14 13:45:00 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

static int	ft_is_object(char *line)
{
	int	i;

	i = 0;
	if (!line)
		return (0);
	while (line[i] == ' ')
		i++;
	if (!ft_strncmp(&line[i], "sp ", 3))
		return (1);
	if (!ft_strncmp(&line[i], "pl ", 3))
		return (1);
	if (!ft_strncmp(&line[i], "cy ", 3))
		return (1);
	return (0);
}

static int	*ft_count(char *file)
{
	int		*count;
	int		fd;
	char	*line;
	char	*trimmed;
	int		i;

	count = ft_calloc(2, sizeof(int));
	if (!count)
		ft_exit(ERROR_MALLOC, 2);
	fd = ft_get_fd(file);
	line = get_next_line(fd);
	while (line)
	{
		trimmed = ft_strtrim(line, " \t\r\b\n");
		free(line);
		if (!trimmed)
			break ;
		ft_tab_to_space(trimmed);
		i = 0;
		while (trimmed[i] == ' ')
			i++;
		if (!ft_strncmp(&trimmed[i], "L ", 2))
			count[0]++;
		else if (ft_is_object(trimmed))
			count[1]++;
		
		free(trimmed);
		line = get_next_line(fd);
	}
	close(fd);
	return (count);
}

static char	*ft_is_double(t_args *args, char *target, char *line, int fd)
{
	if (target)
	{
		free(line);
		ft_free_args(args);
		close(fd);
		ft_exit(ERROR_SCENE, 2);
	}
	return (ft_strdup(line));
}

// 1 - set args NULL
// 2 - strtrim for erase spaces
// 3 - fill scruct according the type of the lines
// 4 - Cam and ambient light can't duplicate
// if invalid argument, call ft_is_double for free and exit
void	ft_put_argument(t_args *args, int fd)
{
	int		i;
	int		k;
	char	*line;
	char	*trimmed;

	args->ambient_light = NULL;
	i = 0;
	k = 0;
	line = get_next_line(fd);
	while (line)
	{
		trimmed = ft_strtrim(line, " \t\r\b\n");
		ft_tab_to_space(trimmed);
		
		if (!ft_strncmp(trimmed, "A ", 2))
			args->ambient_light = ft_is_double(args,
					args->ambient_light, trimmed, fd);
		else if (!ft_strncmp(trimmed, "C ", 2))
			args->camera = ft_is_double(args, args->camera, trimmed, fd);
		else if (!ft_strncmp(trimmed, "L ", 2))
			args->light[k++] = ft_strdup(trimmed);
		else if (ft_is_object(trimmed))
			args->objects[i++] = ft_strdup(trimmed);
		else if (trimmed[0] != '\n' && trimmed[0] != '#' && trimmed[0] != '\0')
			ft_is_double(args, "invalid", trimmed, fd);
		
		free(trimmed);
		free(line);
		line = get_next_line(fd);
	}
}

// 1- call ft_count to get number of the Lights and objets
// 2 - allocate memory for struct and arrays-arrays
// 3 - call ft_put_argument to fill struct
t_args	*ft_allocate_args(char *file)
{
	t_args	*args;
	int		*count;
	int		fd;

	count = ft_count(file);
	args = ft_calloc(sizeof(t_args), 1);
	if (!args)
		ft_exit(ERROR_MALLOC, 2);
	args->camera = NULL;
	args->light_count = count[0];
	args->obj_count = count[1];
	free(count);
	args->objects = ft_calloc(sizeof(char *), (args->obj_count + 1));
	if (!args->objects)
		ft_exit(ERROR_MALLOC, 2);
	args->objects[args->obj_count] = NULL;
	if (args->light_count > 0)
	{
		args->light = ft_calloc(sizeof(char *), (args->light_count + 1));
		if (!args->light_count)
			ft_exit(ERROR_MALLOC, 2);
		args->objects[args->light_count] = NULL;
	}
	fd = ft_get_fd(file);
	ft_put_argument(args, fd);
	close(fd);
	return (args);
}

===== srcs/parser/3-parser.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3-parser.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/15 12:38:39 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 21:23:52 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_scene	*ft_parser(t_args *args)
{
	t_scene	*scene;

	scene = ft_calloc(sizeof(t_scene), 1);
	scene->light_count = args->light_count;
	scene->object_count = args->obj_count;
	scene->ambient = ft_parser_al(args->ambient_light);
	scene->camera = ft_parser_c(args->camera);
	scene->lights = ft_parser_l(args->light, scene->light_count);
	scene->objects = ft_parser_ob(args->objects, scene->object_count);
	if (scene->ambient == NULL || scene->camera == NULL
		|| (scene->light_count > 0 && scene->lights == NULL)
		|| (scene->objects == NULL))
	{
		ft_free_args(args);
		ft_free_scene(scene);
		ft_exit(ERROR_SCENE, 2);
	}
	scene->camera->camdata = ft_compute_camera(*scene->camera, WIDTH, HEIGHT);
	return (scene);
}

// 1 - count parts to verified if have 3 arguments.
// 2 - if with 3 condictions:
//		first argument is 'A'.
//			parser ratio, if arguments is a float 0.0 - 1.0.
//				parser RGB xxx,xxx,xxx.
// 3 - strdup and get rgb for allocate arguments.
t_ambient_light	*ft_parser_al(char *input)
{
	t_ambient_light	*al;
	char			**args;

	if (count_parts(input, ' ') != 3)
		return (NULL);
	args = ft_split(input, ' ');
	if (ft_strncmp(args[0], "A", ft_strlen(args[0])) != 0
		|| !ft_parser_ratio(args[1], 0.0, 1.0)
		|| !ft_parser_rgb(args[2]))
	{
		ft_free_split(args);
		return (NULL);
	}
	al = ft_calloc(sizeof(t_ambient_light), 1);
	al->ratio = ft_atod(args[1]);
	al->color = ft_get_rgb(args[2]);
	ft_free_split(args);
	return (al);
}

t_camera	*ft_parser_c(char *input)
{
	t_camera	*camera;
	char		**args;

	if (count_parts(input, ' ') != 4)
		return (NULL);
	args = ft_split(input, ' ');
	if (ft_strncmp(args[0], "C", ft_strlen(args[0])) != 0
		|| !ft_parser_vec3(args[1])
		|| !ft_is_normalized(args[2])
		|| !ft_parse_fov(args[3]))
	{
		ft_free_split(args);
		return (NULL);
	}
	camera = ft_calloc(sizeof(t_camera), 1);
	camera->position = ft_get_vec3(args[1]);
	camera->vector = ft_get_vec3(args[2]);
	camera->fov = ft_atod(args[3]);
	ft_free_split(args);
	return (camera);
}

t_light	**ft_parser_l(char **input, int count_light)
{
	t_light	**light;
	char	**args;
	int		i;

	if (!input || count_light <= 0)
		return (NULL);
	light = (t_light **)ft_alloc_arraystruc(count_light, sizeof(t_light));
	if (!light)
		return (NULL);
	i = 0;
	while (i < count_light)
	{
		if (!input[i]) 
			break;
		if (count_parts(input[i], ' ') != 4)
			return (ft_free_arraystruc((void **)light, count_light), NULL);
		args = ft_split(input[i], ' ');
		if (!args || !args[0] || !args[1] || !args[2] || !args[3] || 
			ft_strncmp(args[0], "L", ft_strlen(args[0])) != 0
			|| !ft_parser_vec3(args[1])
			|| !ft_parser_ratio(args[2], 0, 1)
			|| !ft_parser_rgb(args[3]))
		{
			ft_free_split(args);
			return (ft_free_arraystruc((void **)light, count_light), NULL);
		}
		light[i]->position = ft_get_vec3(args[1]);
		light[i]->ratio = ft_atod(args[2]);
		light[i]->color = ft_get_rgb(args[3]);
		ft_free_split(args);
		i++;
	}
	return (light);
}

t_object	**ft_parser_ob(char **input, int count_objects)
{
	t_object	**objects;
	int			i;

	if (!input || count_objects <= 0)
		return (NULL);
	objects = (t_object **)ft_alloc_arraystruc(count_objects, sizeof(t_object));
	if (!objects)
		return (NULL);
	i = 0;
	while (i < count_objects)
	{
		if (!input[i]) 
			break;
		objects[i]->type = ft_get_type(input[i]);
		if (objects[i]->type == INVALID)
			return (ft_free_objects_struc(objects, count_objects), NULL);
		objects[i]->data = ft_get_obj(objects[i]->type, input[i]);
		if (objects[i]->data == NULL)
			return (ft_free_objects_struc(objects, count_objects), NULL);
		i++;
	}
	return (objects);
}

===== srcs/parser/3.1-parser_utils.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   3.1-parser_utils.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/19 16:20:22 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 21:25:21 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

// verified if all str value is a number
int	ft_is_number(char *str)
{
	int	i;

	i = 0;
	if (!str || !*str)
		return (0);
	while (str[i])
	{
		if (str[i] < '0' || str[i] > '9')
			return (0);
		i++;
	}
	return (1);
}

// 1 - verified if have 3 parts when we split with ","
// 2 - check if each part is a number and if it are between 0 - 255. 
int	ft_parser_rgb(char *str)
{
	char	**s;
	int		i;
	int		value;

	s = ft_split(str, ',');
	if (!s || count_parts(str, ',') != 3)
		return (ft_free_split(s), 0);
	i = -1;
	while (++i < 3)
	{
		if (!ft_is_number(s[i]))
			return (ft_free_split(s), 0);
		value = ft_atoi(s[i]);
		if (value < 0 || value > 255)
			return (ft_free_split(s), 0);
	}
	ft_free_split(s);
	return (1);
}

// 1- call float format for check if the argument is a float
// 2 - check if value are between min and max
int	ft_parser_ratio(char *str, double min, double max)
{
	float	value;

	if (!ft_float_format(str))
		return (0);
	value = ft_atod(str);
	if (value < min || value > max)
		return (0);
	return (1);
}

// 1 - verify if have 3 parts when we split with ",".
// 2 - check if all parts are in float format.
int	ft_parser_vec3(char *str)
{
	char	**p;

	if (!str)
		return (0);
	p = ft_split(str, ',');
	if (!p || count_parts(str, ',') != 3 || !p[0] || !p[1] || !p[2])
	{
		ft_free_split(p);
		return (0);
	}
	if (!ft_float_format(p[0])
		|| !ft_float_format(p[1])
		|| !ft_float_format(p[2]))
	{
		ft_free_split(p);
		return (0);
	}
	ft_free_split(p);
	return (1);
}

// 1 - call parser vec3 for verify if str is a vector with 3 argument
// 2 - call parser ratio, check if is a float and between -1 and 1.
int	ft_is_normalized(char *str)
{
	char	**args;
	double	x;
	double	y;
	double	z;

	if (!ft_parser_vec3(str))
		return (0);
	args = ft_split(str, ',');
	if (!args)
		return (0);
	if (!ft_parser_ratio(args[0], -1, 1)
		|| !ft_parser_ratio(args[1], -1, 1)
		|| !ft_parser_ratio(args[2], -1, 1))
	{
		ft_free_split(args);
		return (0);
	}
	x = ft_atod(args[0]);
	y = ft_atod(args[1]);
	z = ft_atod(args[2]);
	ft_free_split(args);
	if (x == 0.0 && y == 0.0 && z == 0.0)
		return (0);
	return (1);
}

===== srcs/parser/support_functions.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_functions.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/06 16:46:12 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 21:16:37 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

int	ft_is_rt(char *file)
{
	size_t	len;

	if (!file)
		return (1);
	len = ft_strlen(file);
	if (len < 3)
		return (1);
	if (ft_strncmp(file + len - 3, ".rt", 3) != 0)
		return (1);
	return (0);
}

int	ft_get_fd(char *file)
{
	int	fd;

	fd = open(file, O_RDONLY);
	if (fd < 0)
		ft_exit(ERROR_FILE, 2);
	return (fd);
}

void	ft_free_split(char **arr)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

void	ft_free_args(t_args *args)
{
	if (args->ambient_light)
		free(args->ambient_light);
	if (args->camera)
		free(args->camera);
	if (args->light)
		ft_free_split(args->light);
	if (args->objects)
		ft_free_split(args->objects);
	free(args);
}

===== srcs/parser/support_functions1.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_functions1.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/20 16:13:14 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/14 13:35:42 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"
/*this file have free functions.*/

void	ft_free_arraystruc(void **arr, int count)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (i < count)
	{
		if (arr[i])
			free(arr[i]);
		i++;
	}
	free(arr);
}

void	ft_free_scene(t_scene *scene)
{
	int	i;

	if (!scene)
		return ;
	if (scene->ambient)
		free(scene->ambient);
	if (scene->camera)
		free(scene->camera);
	if (scene->lights)
	{
		i = 0;
		while (i < scene->light_count)
		{
			if (scene->lights[i])
				free(scene->lights[i]);
			i++;
		}
		free(scene->lights);
	}
	if (scene->objects)
		ft_free_objects_struc(scene->objects, scene->object_count);
	free(scene);
}

void	ft_free_object(t_object *obj)
{
	if (!obj)
		return ;
	if (obj->data)
	{
		if (obj->type == SPHERE)
			free((t_sphere *)obj->data);
		else if (obj->type == PLANE)
			free((t_plane *)obj->data);
		else if (obj->type == CYLINDER)
			free((t_cylinder *)obj->data);
	}
	free(obj);
}

void	ft_free_objects_struc(t_object **arr, int count)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (i < count)
	{
		if (arr[i])
			ft_free_object(arr[i]);
		i++;
	}
	free(arr);
}

===== srcs/vectors/vec3_add.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_add.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:46:45 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:19:19 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_add(t_vec3 vec1, t_vec3 vec2)
{
	return (vec3_new(vec1.x + vec2.x, vec1.y + vec2.y, vec1.z + vec2.z));
}

===== srcs/vectors/vec3_atovec3.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_atovec3.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:18:28 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:22:44 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	atovec3(char **vec)
{
	return ((t_vec3)
		{
			.x = ft_atod(vec[0]),
			.y = ft_atod(vec[1]),
			.z = ft_atod(vec[2]),
		}
	);
}

===== srcs/vectors/vec3_cmp.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_cmp.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:54:32 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:19:47 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

bool	vec3_cmp(t_vec3 vec1, t_vec3 vec2)
{
	return (vec1.x == vec2.x && vec1.y == vec2.y && vec1.z == vec2.z);
}

===== srcs/vectors/vec3_cos.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_cos.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:58:24 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:20:24 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

double	vec3_cos(t_vec3 vec1, t_vec3 vec2)
{
	double	dot;
	double	len;

	dot = vec3_dot(vec1, vec2);
	len = vec3_len(vec1) * vec3_len(vec2);
	return (dot / len);
}

===== srcs/vectors/vec3_dot.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_dot.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:04:13 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:20:34 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

double	vec3_dot(t_vec3 vec1, t_vec3 vec2)
{
	return (vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z);
}

===== srcs/vectors/vec3_len.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_len.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:12:11 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:20:44 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

double	vec3_len(t_vec3 vec)
{
	return (sqrt(pow(vec.x, 2) + pow(vec.y, 2) + pow(vec.z, 2)));
}

===== srcs/vectors/vec3_new.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_new.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:44:22 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:20:53 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_new(double x, double y, double z)
{
	return ((t_vec3){x, y, z});
}

===== srcs/vectors/vec3_scale.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_scale.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:29:21 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:21:18 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_scale(t_vec3 vec1, double scalar)
{
	return (vec3_new(vec1.x * scalar, vec1.y * scalar, vec1.z * scalar));
}

===== srcs/vectors/vec3_sub.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_sub.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:35:48 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/02 15:21:26 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_sub(t_vec3 vec1, t_vec3 vec2)
{
	return (vec3_new(vec1.x - vec2.x, vec1.y - vec2.y, vec1.z - vec2.z));
}

===== srcs/vectors/vec3_cross.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_cross.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 18:59:59 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/13 19:09:19 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_cross(t_vec3 vec1, t_vec3 vec2)
{
	t_vec3	res;

	res.x = vec1.y * vec2.z - vec1.z * vec2.y;
	res.y = vec1.z * vec2.x - vec1.x * vec2.z;
	res.z = vec1.x * vec2.y - vec1.y * vec2.x;
	return (res);
}

===== srcs/vectors/vec3_normalize.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vec3_normalize.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/23 19:28:05 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/13 21:16:31 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_vec3	vec3_normalize(t_vec3 vec)
{
	double	len;

	len = vec3_len(vec);
	if (len < 1e-10)
		return (vec3_new(0, 0, 1));
	return (vec3_scale(vec, 1.0 / len));
}

===== srcs/graphics/events.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   events.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 19:42:38 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/14 13:31:49 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

int	close_window(t_scene *scene)
{
	void	*mlx_ptr;

	if (!scene)
		exit(0);
	mlx_ptr = scene->disp.mlx;
	if (scene->disp.img)
		mlx_destroy_image(scene->disp.mlx, scene->disp.img);
	if (scene->disp.win)
		mlx_destroy_window(scene->disp.mlx, scene->disp.win);
	ft_free_scene(scene);
	if (mlx_ptr)
	{
		mlx_destroy_display(scene->disp.mlx);
		free(mlx_ptr);
	}
	exit(0);
	return (0);
}

int	key_press(int keycode, t_scene *scene)
{
	if (keycode == 65307)
		close_window(scene);
	return (0);
}

===== srcs/graphics/minilibx_setup.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minilibx_setup.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/01 19:33:59 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/13 21:16:51 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

void	ft_init_graphics(t_scene *scene)
{
	scene->disp.mlx = mlx_init();
	if (!scene->disp.mlx)
		ft_exit("Error: MLX initialization failed", 1);
	scene->disp.win = mlx_new_window(scene->disp.mlx, WIDTH, HEIGHT, "miniRT");
	if (!scene->disp.win)
		ft_exit("Error: Window creation failed", 1);
	scene->disp.img = mlx_new_image(scene->disp.mlx, WIDTH, HEIGHT);
	if (!scene->disp.img)
		ft_exit("Error: Image creation failed", 1);
	scene->disp.addr = mlx_get_data_addr(scene->disp.img, &scene->disp.bpp,
			&scene->disp.line_length, &scene->disp.endian);
	if (!scene->disp.addr)
		ft_exit("Error: Image address failed", 1);
}

===== srcs/ray/cam_data.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cam_data.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/02 16:42:02 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 21:16:53 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_camdata	ft_compute_camera(t_camera cam, int width, int height)
{
	t_camdata	c;
	t_vec3		world_up;

	world_up = ft_get_vec3("0,1,0");
	c.forward = vec3_normalize(cam.vector);
	if (fabs(vec3_dot(c.forward, world_up)) > 0.999)
		world_up = ft_get_vec3("0,0,1");
	c.right = vec3_normalize(vec3_cross(c.forward, world_up));
	c.up = vec3_cross(c.right, c.forward);
	c.fov_rad = cam.fov * M_PI / 180.0;
	c.viewport_height = 2 * tan(c.fov_rad / 2);
	c.viewport_width = c.viewport_height * ((double)width / height);
	return (c);
}

===== srcs/ray/ray.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ray.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/03 15:41:55 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 20:57:08 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_ray	ft_ray(t_vec3 o, t_vec3 d)
{
	t_ray	r;

	r.origin = o;
	r.direction = vec3_normalize(d);
	return (r);
}

t_ray	make_ray(int x, int y, t_scene *scene)
{
	double	u;
	double	v;
	t_vec3	pixel_dir;

	u = (double)x / (WIDTH - 1);
	v = (double)y / (HEIGHT - 1);
	u = u - 0.5;
	v = 0.5 - v;
	pixel_dir = vec3_add(vec3_add(
				vec3_scale(scene->camera->camdata.right,
					u * scene->camera->camdata.viewport_width),
				vec3_scale(scene->camera->camdata.up,
					v * scene->camera->camdata.viewport_height)),
			scene->camera->camdata.forward);
	return (ft_ray(scene->camera->position, pixel_dir));
}

===== srcs/object_intersection/hit_cylinder.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_cylinder.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/08 15:45:05 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/12 19:02:37 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

#define EPSILON 1e-6
#define INF_VAL 1e30

static bool	cy_lateral(t_ray ray, t_cylinder *cy, double *out);
static bool	cy_cap(t_ray ray, t_cylinder *cy, double *out, int top);

bool	hit_cylinder(t_ray ray, t_cylinder *cy, double *t)
{
	double	t_lateral;
	double	t_top;
	double	t_bottom;
	bool	hit;

	t_lateral = INF_VAL;
	t_top = INF_VAL;
	t_bottom = INF_VAL;
	hit = false;
	if (cy_lateral(ray, cy, &t_lateral))
		hit = true;
	if (cy_cap(ray, cy, &t_top, 1))
		hit = true;
	if (cy_cap(ray, cy, &t_bottom, 0))
		hit = true;
	if (!hit)
		return (false);
	/* escolher menor t válido */
	*t = t_lateral;
	if (t_top < *t && t_top > EPSILON)
		*t = t_top;
	if (t_bottom < *t && t_bottom > EPSILON)
		*t = t_bottom;
	return (true);
}

/*
 * caps: top == 1 -> top cap ; top == 0 -> bottom cap
 * assume cy->center is the base (bottom). top center = center + normal*height
 */
static bool	cy_cap(t_ray ray, t_cylinder *cy, double *out, int top)
{
	t_plane	pl;
	t_vec3	center;
	t_vec3	p;
	double	t;

	if (top)
		center = vec3_add(cy->center, vec3_scale(cy->normal, cy->height));
	else
		center = cy->center;
	/* montar plane temporário (precisa de color) */
	pl.point = center;
	pl.normal = cy->normal;
	pl.color = (t_rgb){0, 0, 0}; /* color não usado por hit_plane, só para inicializar */
	if (!hit_plane(ray, &pl, &t))
		return (false);
	if (t < EPSILON)
		return (false);
	p = vec3_add(ray.origin, vec3_scale(ray.direction, t));
	if (vec3_len(vec3_sub(p, center)) <= cy->diameter / 2.0)
	{
		*out = t;
		return (true);
	}
	return (false);
}

static bool	cy_lateral(t_ray ray, t_cylinder *cy, double *out)
{
	t_vec3	oc;
	t_vec3	d;
	t_vec3	w;
	double	a;
	double	b;
	double	c;
	double	discriminant;
	double	t1;
	double	t2;
	t_vec3	p;
	double	h;

	oc = vec3_sub(ray.origin, cy->center);
	/* remove componente paralela ao eixo */
	d = vec3_sub(ray.direction,
			vec3_scale(cy->normal, vec3_dot(ray.direction, cy->normal)));
	w = vec3_sub(oc, vec3_scale(cy->normal, vec3_dot(oc, cy->normal)));
	a = vec3_dot(d, d);
	b = 2 * vec3_dot(d, w);
	c = vec3_dot(w, w) - (cy->diameter * cy->diameter) / 4.0;
	discriminant = b * b - 4 * a * c;
	if (discriminant < 0.0 || fabs(a) < EPSILON)
		return (false);
	t1 = (-b - sqrt(discriminant)) / (2 * a);
	t2 = (-b + sqrt(discriminant)) / (2 * a);
	/* testa t1 */
	if (t1 > EPSILON)
	{
		p = vec3_add(ray.origin, vec3_scale(ray.direction, t1));
		h = vec3_dot(vec3_sub(p, cy->center), cy->normal);
		if (h >= 0.0 && h <= cy->height)
		{
			*out = t1;
			return (true);
		}
	}
	/* testa t2 */
	if (t2 > EPSILON)
	{
		p = vec3_add(ray.origin, vec3_scale(ray.direction, t2));
		h = vec3_dot(vec3_sub(p, cy->center), cy->normal);
		if (h >= 0.0 && h <= cy->height)
		{
			*out = t2;
			return (true);
		}
	}
	return (false);
}

===== srcs/object_intersection/hit_sphere.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_sphere.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/08 15:36:51 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/08 16:47:33 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

bool	hit_sphere(t_ray ray, t_sphere *sp, double *t)
{
	t_vec3	oc;
	double	a;
	double	b;
	double	c;
	double	delta;
	double	sqrt_d;
	double	t0;
	double	t1;

	oc = vec3_sub(ray.origin, sp->center);
	a = vec3_dot(ray.direction, ray.direction);
	b = 2.0 * vec3_dot(oc, ray.direction);
	c = vec3_dot(oc, oc) - (sp->diameter / 2) * (sp->diameter / 2);
	delta = b * b - 4 * a * c;
	if (delta < 0)
		return (false);
	sqrt_d = sqrt(delta);
	t0 = (-b - sqrt_d) / (2 * a);
	t1 = (-b + sqrt_d) / (2 * a);
	if (t0 > 1e-6)
	{
		*t = t0;
		return (true);
	}
	if (t1 > 1e-6)
	{
		*t = t1;
		return (true);
	}
	return (false);
}

===== srcs/object_intersection/hit_objects.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_objects.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/10 15:39:35 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 19:48:17 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

bool	hit_objects(t_scene *scene, t_ray ray, t_hit *hit)
{
	double		t;
	int			i;
	t_object	*obj;

	hit->t = INFINITY;
	hit->object = NULL;
	hit->type = INVALID;
	i = 0;
	while (i < scene->object_count)
	{
		obj = scene->objects[i];
		if (obj->type == SPHERE)
		{
			if (hit_sphere(ray, (t_sphere *)obj->data, &t))
			{
				if (t > 1e-6 && t < hit->t)
				{
					hit->t = t;
					hit->object = obj->data;
					hit->type = SPHERE;
				}
			}
		}
		else if (obj->type == PLANE)
		{
			if (hit_plane(ray, (t_plane *)obj->data, &t))
			{
				if (t > 1e-6 && t < hit->t)
				{
					hit->t = t;
					hit->object = obj->data;
					hit->type = PLANE;
				}
			}
		}
		else if (obj->type == CYLINDER)
		{
			if (hit_cylinder(ray, (t_cylinder *)obj->data, &t))
			{
				if (t > 1e-6 && t < hit->t)
				{
					hit->t = t;
					hit->object = obj->data;
					hit->type = CYLINDER;
				}
			}
		}
		i++;
	}
	return (hit->object != NULL);
}

===== srcs/object_intersection/hit_plane.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hit_plane.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/08 15:42:52 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 15:09:54 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

bool	hit_plane(t_ray ray, t_plane *pl, double *t)
{
	double	denom;
	t_vec3	p0l0;
	double	temp_t;

	denom = vec3_dot(pl->normal, ray.direction);
	if (fabs(denom) < 1e-6)
		return (false);
	p0l0 = vec3_sub(pl->point, ray.origin);
	temp_t = vec3_dot(p0l0, pl->normal) / denom;
	if (temp_t < 1e-6)
		return (false);
	*t = temp_t;
	return (true);
}

===== srcs/lighting/ambient_light.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ambiente_light.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 14:50:40 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 15:14:11 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_rgb	apply_ambient(t_scene *sc, t_rgb obj_color)
{
	t_rgb	res;

	res.r = obj_color.r * sc->ambient->ratio * (sc->ambient->color.r / 255.0);
	res.g = obj_color.g * sc->ambient->ratio * (sc->ambient->color.g / 255.0);
	res.b = obj_color.b * sc->ambient->ratio * (sc->ambient->color.b / 255.0);
	return (res);
}

===== srcs/lighting/diffuse.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   diffuse.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 14:51:58 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 14:58:31 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_rgb	apply_diffuse(t_vec3 normal, t_vec3 light_dir,
							t_light *light, t_rgb obj_color)
{
	double	diff;
	t_rgb	res;

	diff = vec3_dot(normal, light_dir);
	if (diff < 0)
		diff = 0;
	res.r = obj_color.r * diff * light->ratio * (light->color.r / 255.0);
	res.g = obj_color.g * diff * light->ratio * (light->color.g / 255.0);
	res.b = obj_color.b * diff * light->ratio * (light->color.b / 255.0);
	return (res);
}

===== srcs/lighting/shade_hit.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shade_hit.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lgertrud <lgertrud@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 14:57:47 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 15:12:05 by lgertrud         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

t_rgb	shade_hit(t_scene *sc, t_hit *hit, t_vec3 point, t_vec3 normal)
{
	t_rgb	color;
	t_rgb	tmp;
	int		i;
	t_rgb	obj_color;

	if (hit->type == SPHERE)
		obj_color = ((t_sphere *)hit->object)->color;
	else if (hit->type == PLANE)
		obj_color = ((t_plane *)hit->object)->color;
	else
		obj_color = ((t_cylinder *)hit->object)->color;
	color = apply_ambient(sc, obj_color);
	i = 0;
	while (i < sc->light_count)
	{
		if (!is_in_shadow(sc, point, sc->lights[i]))
		{
			tmp = apply_diffuse(normal,
					vec3_normalize(vec3_sub(sc->lights[i]->position, point)),
					sc->lights[i], obj_color);
			color = rgb_add(color, tmp);
		}
		i++;
	}
	return (rgb_clamp(color));
}

===== srcs/lighting/support_lighting.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   support_lighting.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 14:55:04 by lgertrud          #+#    #+#             */
/*   Updated: 2025/12/13 19:48:38 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

bool	is_in_shadow(t_scene *sc, t_vec3 point, t_light *light)
{
	t_ray	shadow;
	t_hit	tmp;
	t_vec3	to_light;
	double	dist;

	to_light = vec3_sub(light->position, point);
	dist = vec3_len(to_light);
	to_light = vec3_normalize(to_light);
	shadow.origin = vec3_add(point, vec3_scale(to_light, 1e-4));
	shadow.direction = to_light;
	if (hit_objects(sc, shadow, &tmp))
	{
		if (tmp.t > 1e-6 && tmp.t < dist)
			return (true);
	}
	return (false);
}

t_rgb	rgb_add(t_rgb a, t_rgb b)
{
	t_rgb	c;

	c.r = a.r + b.r;
	c.g = a.g + b.g;
	c.b = a.b + b.b;
	return (c);
}

t_rgb	rgb_clamp(t_rgb c)
{
	if (c.r > 255)
		c.r = 255;
	if (c.g > 255)
		c.g = 255;
	if (c.b > 255)
		c.b = 255;
	if (c.r < 0)
		c.r = 0;
	if (c.g < 0)
		c.g = 0;
	if (c.b < 0)
		c.b = 0;
	return (c);
}

int	rgb_to_int(t_rgb color)
{
	int	r;
	int	g;
	int	b;

	r = (int)color.r;
	g = (int)color.g;
	b = (int)color.b;
	if (r < 0) r = 0;
	if (r > 255) r = 255;
	if (g < 0) g = 0;
	if (g > 255) g = 255;
	if (b < 0) b = 0;
	if (b > 255) b = 255;
	return (r << 16 | g << 8 | b);
}

===== srcs/render/normal.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   normal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 19:01:14 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/13 21:16:40 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

static t_vec3	get_cylinder_normal(t_hit *hit, t_vec3 point)
{
	t_cylinder	*cy;
	t_vec3		to_point;
	double		proj;
	t_vec3		point_on_axis;
	double		dist_to_base;
	double		dist_to_top;

	cy = (t_cylinder *)hit->object;
	to_point = vec3_sub(point, cy->center);
	proj = vec3_dot(to_point, cy->normal);
	dist_to_base = fabs(proj);
	dist_to_top = fabs(proj - cy->height);
	
	if (dist_to_base < 1e-4)
		return (vec3_scale(cy->normal, -1.0));
	if (dist_to_top < 1e-4)
		return (cy->normal);
	point_on_axis = vec3_add(cy->center, vec3_scale(cy->normal, proj));
	return (vec3_normalize(vec3_sub(point, point_on_axis)));
}

t_vec3	get_normal(t_hit *hit, t_vec3 point)
{
	t_vec3	normal;
	t_sphere	*sp;
	t_plane		*pl;

	if (hit->type == SPHERE)
	{
		sp = (t_sphere *)hit->object;
		normal = vec3_normalize(vec3_sub(point, sp->center));
	}
	else if (hit->type == PLANE)
	{
		pl = (t_plane *)hit->object;
		normal = vec3_normalize(pl->normal);
	}
	else if (hit->type == CYLINDER)
		normal = get_cylinder_normal(hit, point);
	else
		normal = vec3_new(0, 1, 0);
	return (normal);
}

===== srcs/render/render.c =====
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ghenriqu <ghenriqu@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/13 18:48:20 by ghenriqu          #+#    #+#             */
/*   Updated: 2025/12/14 13:35:32 by ghenriqu         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minirt.h"

void    render_scene(t_scene *scene)
{
    int     x;
    int     y;
    t_ray   ray;
    t_hit   hit;
    t_rgb   color;
    t_vec3  point;
    t_vec3  normal;

	if (!scene || !scene->disp.mlx || !scene->disp.win || !scene->disp.img)
	{
		printf("Error: Invalid scene or display\n");
		return ;
	}
    y = 0;
    while (y < HEIGHT)
    {
        x = 0;
        while (x < WIDTH)
        {
            ray = make_ray(x, y, scene);
            if (hit_objects(scene, ray, &hit))
            {
				point = vec3_add(ray.origin, vec3_scale(ray.direction, hit.t));
				normal = get_normal(&hit, point);
				color = shade_hit(scene, &hit, point, normal);
            }
			else
				color = (t_rgb){0, 0, 0};
			put_pixel(scene, x, y, rgb_to_int(color));
			x++;
		}
		y++;
    }
	if (scene->disp.mlx && scene->disp.win && scene->disp.img)
		mlx_put_image_to_window(scene->disp.mlx, scene->disp.win,
				scene->disp.img, 0, 0);
}

void	put_pixel(t_scene *scene, int x, int y, int color)
{
	char	*dst;

	if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
		return;
	
	dst = scene->disp.addr + (y * scene->disp.line_length 
							+ x * (scene->disp.bpp / 8));
	*(unsigned int *)dst = color;
}

